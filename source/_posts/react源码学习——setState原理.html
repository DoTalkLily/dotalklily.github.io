---
layout: post
title:  react源码学习——setState原理
date:   2017-02-14 08:43:59
author: Lily
categories: frontend
tags:
- react
- 源码解读
---
<div>
    React通过this.setState方法更新state，当this.setState被调用的时候会根据更新策略执行情况（是否在更新中）来判断是否重新调用render方法还是放到更新队列中。看下setState源码，题外话：React创建组件有三种方式:
    1）函数方式(无状态组件) 2）React.createClass(es5)  3) extends React.Component(es6)，后两种方式中
    setState会自动注入到组件中，因此在自定义组件中能通过this.setState直接访问。三种创建方式的区别参见<a
        href="http://www.cnblogs.com/wonyun/p/5930333.html">这篇文章</a>。<br>
    <div>——以下代码是React v15.4.2版本——</div>
</div>
<div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><br/><span
        style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Sets a subset of the state. Always use this to mutate<br/></span><span
        style="color:#629755;font-style:italic;"> * state. You should treat `this.state` as immutable.<br/></span><span
        style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * There is no guarantee that `this.state` will be immediately updated, so<br/></span><span
        style="color:#629755;font-style:italic;"> * accessing `this.state` after calling this method may return the old value.<br/></span><span
        style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * There is no guarantee that calls to `setState` will run synchronously,<br/></span><span
        style="color:#629755;font-style:italic;"> * as they may eventually be batched together.  You can provide an optional<br/></span><span
        style="color:#629755;font-style:italic;"> * callback that will be executed when the call to setState is actually<br/></span><span
        style="color:#629755;font-style:italic;"> * completed.<br/></span><span
        style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * When a function is provided to setState, it will be called at some point in<br/></span><span
        style="color:#629755;font-style:italic;"> * the future (not synchronously). It will be called with the up to date<br/></span><span
        style="color:#629755;font-style:italic;"> * component arguments (state, props, context). These values can be different<br/></span><span
        style="color:#629755;font-style:italic;"> * from this.* because your function may be called after receiveProps but before<br/></span><span
        style="color:#629755;font-style:italic;"> * shouldComponentUpdate, and this new state, props, and context will not yet be<br/></span><span
        style="color:#629755;font-style:italic;"> * assigned to this.<br/></span><span
        style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * </span><span
        style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span
        style="color:#629755;font-style:italic;">{object|function} partialState Next partial state or function to<br/></span><span
        style="color:#629755;font-style:italic;"> *        produce next partial state to be merged with current state.<br/></span><span
        style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span
        style="color:#629755;font-style:italic;">{?function} callback Called after state is updated.<br/></span><span
        style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@final<br/></span><span
        style="color:#629755;font-weight:bold;font-style:italic;"/><span
        style="color:#629755;font-style:italic;">* </span><span style="color:#629755;font-weight:bold;font-style:italic;">@protected<br/></span><span
        style="color:#629755;font-weight:bold;font-style:italic;"/><span
        style="color:#629755;font-style:italic;">*/<br/></span><span style="color:#ffc66d;">ReactComponent</span>.<span
        style="color:#9876aa;">prototype</span>.<span style="color:#ffc66d;">setState </span>= <span
        style="color:#cc7832;font-weight:bold;">function</span>(partialState<span
        style="color:#cc7832;">, </span>callback) {<span style="color:#cc7832;"><br/></span><span
        style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span
        style="color:#9876aa;">updater</span>.<span style="color:#ffc66d;">enqueueSetState</span>(<span
        style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">, </span>partialState<span
        style="color:#cc7832;">, </span>callback<span style="color:#cc7832;">, </span><span
        style="color:#6a8759;">'setState'</span>)<span style="color:#cc7832;">;<br/></span>}<span
        style="color:#cc7832;">;</span>
</pre>
    <pre style="background-color: rgb(43, 43, 43);"><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(169, 183, 198);"><span
            style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Sets a subset of the state. This only exists because _pendingState is<br/></span><span
            style="color:#629755;font-style:italic;"> * internal. This provides a merging strategy that is not available to deep<br/></span><span
            style="color:#629755;font-style:italic;"> * properties which is confusing. </span><span
            style="color:#a8c023;font-style:italic;">TODO: Expose pendingState or don't use it<br/></span><span
            style="color:#a8c023;font-style:italic;"/><span
            style="color:#629755;font-style:italic;">* during the merge.<br/></span><span
            style="color:#629755;font-style:italic;"> *<br/></span><span
            style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span
            style="color:#629755;font-style:italic;">{ReactClass} publicInstance The instance that should rerender.<br/></span><span
            style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span
            style="color:#629755;font-style:italic;">{object} partialState Next partial state to be merged with state.<br/></span><span
            style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span
            style="color:#629755;font-style:italic;">{?function} callback Called after state is updated.<br/></span><span
            style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span
            style="color:#629755;font-style:italic;">{?string} Name of the calling function in the public API.<br/></span><span
            style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@internal<br/></span><span
            style="color:#629755;font-weight:bold;font-style:italic;"/><span
            style="color:#629755;font-style:italic;">*/<br/></span><span style="color:#ffc66d;">enqueueSetState</span>: <span
            style="color:#cc7832;font-weight:bold;">function</span>(publicInstance<span style="color:#cc7832;">, </span>partialState<span
            style="color:#cc7832;">, </span>callback<span style="color:#cc7832;">, </span>callerName) {<br/>  </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#cc7832"><b>//获得组件实例</b></font><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6"><br/>  </font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">var </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">internalInstance = </font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">getInternalInstanceReadyForUpdate</span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(<br/>    publicInstance</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">,<br/></span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">    </span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(106, 135, 89);">'setState'<br/></span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(106, 135, 89);">  </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">)</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);"><br/></span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">  </span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">if </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(!internalInstance) {<br/>    </font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">return</span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">  </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">}<br/><br/>  //初始化state更新队列<br/>  </font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">var </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">queue =<br/>    internalInstance.</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(152, 118, 170);">_pendingStateQueue </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">||<br/>    (internalInstance.</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(152, 118, 170);">_pendingStateQueue </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">= [])</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">  </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">queue.</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">push</span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(partialState)</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">  //如果setState设置了回调函数，添加到组件实例的队列中<br/></span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">  </span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">if </span><font
            style="font-family: Menlo; font-size: 9pt;"
            color="#a9b7c6">(callback) {<br/>    validateCallback(callback</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">, </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">callerName)</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">    </span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">if </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(internalInstance.</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(152, 118, 170);">_pendingCallbacks</span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">) {<br/>      internalInstance.</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(152, 118, 170);">_pendingCallbacks</span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">.</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">push</span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(callback)</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">    </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">} </font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">else </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">{<br/>      internalInstance.</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(152, 118, 170);">_pendingCallbacks </span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">= [callback]</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">    </span><font color="#a9b7c6"><font
            face="Menlo" size="2">}<br/>  }<br/>  <br/>  </font></font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">enqueueUpdate</span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(internalInstance)</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><font
            style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">}</font><span
            style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">,</span></pre>
</div>
<div><font style="font-size: 14px;"><span
        style="font-style: normal; font-variant-caps: normal; font-weight: normal; font-family: 'PingFang SC'; color: rgb(69, 69, 69);">最后调用（</span><span
        style="font-style: normal; font-variant-caps: normal; font-weight: normal; font-family: Helvetica; color: rgb(69, 69, 69);">src/renderers/shared/stack/reconciler/ReactUpdates.js</span><span
        style="font-style: normal; font-variant-caps: normal; font-weight: normal; font-family: 'PingFang SC'; color: rgb(69, 69, 69);">）</span><span
        style="font-style: normal; font-variant-caps: normal; font-weight: normal; font-family: Helvetica; color: rgb(69, 69, 69);">ReactUpdates</span><span
        style="font-style: normal; font-variant-caps: normal; font-weight: normal; font-family: 'PingFang SC'; color: rgb(69, 69, 69);">的enqueueUpdate函数执行更新。</span></font>
</div>
<div><font style="font-size: 14px;"><span
        style="font-style: normal; font-variant-caps: normal; font-weight: normal; color: rgb(69, 69, 69);"/></font><span
        style="font-style: normal; font-variant-caps: normal; font-weight: normal; color: rgb(69, 69, 69);"><font
        style="font-size: 14px;"><font face="PingFang SC"><pre
        style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span
        style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Mark a component as needing a rerender, adding an optional callback to a<br/></span><span
        style="color:#629755;font-style:italic;"> * list of functions which will be executed once the rerender occurs.<br/></span><span
        style="color:#629755;font-style:italic;"> */<br/></span><span style="color:#cc7832;font-weight:bold;">function </span><span
        style="color:#ffc66d;">enqueueUpdate</span>(component) {<br/>  <span
        style="color:#ffc66d;">ensureInjected</span>()<span style="color:#cc7832;">;</span><span style="color:#808080;"><br/></span><span
        style="color:#808080;"><br/></span><span style="color:#808080;">  </span><span
        style="color:#cc7832;font-weight:bold;">if </span>(!batchingStrategy.<span
        style="color:#9876aa;">isBatchingUpdates</span>) {//如果当前没有处于更新中，<br/>    batchingStrategy.<span
        style="color:#ffc66d;">batchedUpdates</span>(<span style="color:#ffc66d;">enqueueUpdate</span><span
        style="color:#cc7832;">, </span>component)<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">return</span><span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/><br/>  dirtyComponents.<span
        style="color:#ffc66d;">push</span>(component)<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(component.<span
        style="color:#9876aa;">_updateBatchNumber </span>== <span style="color:#cc7832;font-weight:bold;">null</span>) {<br/>    component.<span
        style="color:#9876aa;">_updateBatchNumber </span>= updateBatchNumber + <span style="color:#6897bb;">1</span><span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/>}
</pre></font></font></span><br/></div>
<div>
    batchingStrategy在ReactDefaultBatchingStrategy.js（src/renderers/shared/stack/reconciler/ReactDefaultBatchingStrategy.js），这里要介绍下React的事务，事务是将需要执行的方法封装起来，在通过perform方法执行，以保证在执行目标方法前，事务中的一组initialize方法限制性，目标方法执行后，一组close方法能够得到执行，参见下图（src/renderers/shared/stack/reconciler/Transaction.js中）：
</div>
<div><img
        src="/images/2017-02-14/3C5D0315-7718-4DC6-89B9-0C7A281294F2.png"
        height="670" width="1066"/><br/></div>
<div>再回到我们的更新策略对象中</div>
<div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><br/><span
        style="color:#cc7832;font-weight:bold;">var </span>RESET_BATCHED_UPDATES = {<br/>  <span style="color:#9876aa;">initialize</span>: emptyFunction<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span><span
        style="color:#ffc66d;">close</span>: <span style="color:#cc7832;font-weight:bold;">function</span>() {<br/>    ReactDefaultBatchingStrategy.<span
        style="color:#9876aa;">isBatchingUpdates </span>= <span style="color:#cc7832;font-weight:bold;">false</span><span
        style="color:#cc7832;">;//<font
        style="font-family: Menlo; background-color: rgb(43, 43, 43); font-size: 12px; color: rgb(169, 183, 198);">事务执行结束后重置当前更新状态</font><br/></span><span
        style="color:#cc7832;">  </span>}<span style="color:#cc7832;">,<br/></span>}<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;"><br/></span><span
        style="color:#cc7832;font-weight:bold;">var </span>FLUSH_BATCHED_UPDATES = {<br/>  <span style="color:#9876aa;">initialize</span>: emptyFunction<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span><span style="color:#9876aa;">close</span>: ReactUpdates.<span
        style="color:#ffc66d;">flushBatchedUpdates</span>.<span style="color:#ffc66d;">bind</span>(ReactUpdates)<span
        style="color:#cc7832;">,//遍历dirtyComponent数组中的组件，逐个更新<br/></span>}<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">var </span>TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES<span
        style="color:#cc7832;">, </span>RESET_BATCHED_UPDATES]<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;"><br/></span><span style="color:#cc7832;font-weight:bold;">function </span><span
        style="color:#ffc66d;">ReactDefaultBatchingStrategyTransaction</span>() {<br/>  <span
        style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">reinitializeTransaction</span>()<span
        style="color:#cc7832;">;<br/></span>}<br/><br/>Object.<span style="color:#ffc66d;">assign</span>(<br/>  <span
        style="color:#ffc66d;">ReactDefaultBatchingStrategyTransaction</span>.<span
        style="color:#9876aa;">prototype</span><span style="color:#cc7832;">,<br/></span><span
        style="color:#cc7832;">  </span>Transaction<span style="color:#cc7832;">,<br/></span><span
        style="color:#cc7832;">  </span>{<br/>    <span style="color:#ffc66d;">getTransactionWrappers</span>: <span
        style="color:#cc7832;font-weight:bold;">function</span>() { //给事务添加wapper<br/>      <span
        style="color:#cc7832;font-weight:bold;">return </span>TRANSACTION_WRAPPERS<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>}<br/>)<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span
        style="color:#cc7832;font-weight:bold;">var </span>transaction = <span
        style="color:#cc7832;font-weight:bold;">new </span><span style="color:#ffc66d;">ReactDefaultBatchingStrategyTransaction</span>()<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span
        style="color:#cc7832;font-weight:bold;">var </span>ReactDefaultBatchingStrategy = {<br/>  <span
        style="color:#9876aa;">isBatchingUpdates</span>: <span style="color:#cc7832;font-weight:bold;">false</span><span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;"><br/></span><span
        style="color:#cc7832;">  </span><span style="color:#629755;font-style:italic;">/**<br/></span><span
        style="color:#629755;font-style:italic;">   * Call the provided function in a context within which calls to `setState`<br/></span><span
        style="color:#629755;font-style:italic;">   * and friends are batched such that components aren't updated unnecessarily.<br/></span><span
        style="color:#629755;font-style:italic;">   */<br/></span><span
        style="color:#629755;font-style:italic;">  </span><span style="color:#ffc66d;">batchedUpdates</span>: <span
        style="color:#cc7832;font-weight:bold;">function</span>(callback<span style="color:#cc7832;">, </span>a<span
        style="color:#cc7832;">, </span>b<span style="color:#cc7832;">, </span>c<span style="color:#cc7832;">, </span>d<span
        style="color:#cc7832;">, </span>e) {<br/>    <span style="color:#cc7832;font-weight:bold;">var </span>alreadyBatchingUpdates = ReactDefaultBatchingStrategy.<span
        style="color:#9876aa;">isBatchingUpdates</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span
        style="color:#cc7832;">    </span>ReactDefaultBatchingStrategy.<span style="color:#9876aa;">isBatchingUpdates </span>= <span
        style="color:#cc7832;font-weight:bold;">true</span><span style="color:#cc7832;">;//设置当前正在处于更新状态<br/></span><span
        style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;">// The code is written this way to avoid extra allocations<br/></span><span
        style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(alreadyBatchingUpdates) { //个人认为这里是确保同一时间只有一个事务在更新组件，比如一个组件几乎无间隔地调用两次setState，欢迎讨论<br/>      <span
        style="color:#cc7832;font-weight:bold;">return </span>callback(a<span style="color:#cc7832;">, </span>b<span
        style="color:#cc7832;">, </span>c<span style="color:#cc7832;">, </span>d<span style="color:#cc7832;">, </span>e)<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>} <span
        style="color:#cc7832;font-weight:bold;">else </span>{<br/>      <span
        style="color:#cc7832;font-weight:bold;">return </span>transaction.<span style="color:#ffc66d;">perform</span>(callback<span
        style="color:#cc7832;">, </span><span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">, </span>a<span
        style="color:#cc7832;">, </span>b<span style="color:#cc7832;">, </span>c<span style="color:#cc7832;">, </span>d<span
        style="color:#cc7832;">, </span>e)<span style="color:#cc7832;">;//注意这里比较有意思，把<font
        style="font-family: Menlo; font-size: 12px; background-color: rgb(43, 43, 43); color: rgb(255, 198, 109);">enqueueUpdate作为callback调用，但这时<font
        style="font-family: Menlo; font-size: 12px; background-color: rgb(43, 43, 43); color: rgb(152, 118, 170);">isBatchingUpdates是true，因此<font
        style="font-family: Menlo; background-color: rgb(43, 43, 43); font-size: 12px; color: rgb(255, 198, 109);">enqueueUpdate做的事就是把这个要更新的component加入到dirtyComponent数组中，然后在事务wrapper中的close方法</font></font></font></span><span
        style="font-size: 9pt;">ReactUpdates.</span><span style="font-size: 9pt; color: rgb(255, 198, 109);">flushBatchedUpdates遍历dirtyComponent数组进行更新。</span><span
        style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span>}<br/>  }<span
        style="color:#cc7832;">,<br/></span>}<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;"><br/></span>module.<span
        style="color:#ffc66d;">exports </span>= ReactDefaultBatchingStrategy<span style="color:#cc7832;">;<br/></span>
</pre>
    由这段代码可以看到，真正执行更新的实在事务的某个wapper的close方法中，即ReactUpdates.flushBatchedUpdates中进行更新的：
    <pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.8pt;"><span
            style="color:#cc7832;font-weight:bold;">var </span><span style="color:#ffc66d;">flushBatchedUpdates </span>= <span
            style="color:#cc7832;font-weight:bold;">function</span>() {<br/>  <span style="color:#808080;">// ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents<br/></span><span
            style="color:#808080;">  // array and perform any updates enqueued by mount-ready handlers (i.e.,<br/></span><span
            style="color:#808080;">  // componentDidUpdate) but we need to check here too in order to catch<br/></span><span
            style="color:#808080;">  // updates enqueued by setState callbacks.<br/></span><span
            style="color:#808080;">  </span><span style="color:#cc7832;font-weight:bold;">while </span>(dirtyComponents.<span
            style="color:#9876aa;">length</span>) {<br/>    <span style="color:#cc7832;font-weight:bold;">var </span>transaction = <span
            style="color:#ffc66d;">ReactUpdatesFlushTransaction</span>.<span style="color:#ffc66d;">getPooled</span>()<span
            style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>transaction.<span
            style="color:#ffc66d;">perform</span>(<span style="color:#ffc66d;">runBatchedUpdates</span><span
            style="color:#cc7832;">, </span><span style="color:#cc7832;font-weight:bold;">null</span><span
            style="color:#cc7832;">, </span>transaction)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span
            style="color:#ffc66d;">ReactUpdatesFlushTransaction</span>.<span
            style="color:#ffc66d;">release</span>(transaction)<span style="color:#cc7832;">;<br/></span><span
            style="color:#cc7832;">  </span>}<br/>}<span style="color:#cc7832;">;</span>
</pre>
</div>
<div>注意这里由用到一个事务ReactUpdatesFlushTransaction：</div>
<div><pre style="background-color: rgb(43, 43, 43);"><font face="Menlo" color="#a9b7c6" size="3"><br/></font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">var </span><font
        face="Menlo" color="#a9b7c6" size="3">NESTED_UPDATES = {<br/>  </font><span
        style="color: rgb(255, 198, 109); font-family: Menlo; font-size: 9.8pt;">initialize</span><font face="Menlo"
                                                                                                        color="#a9b7c6"
                                                                                                        size="3">: </font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">function</span><font
        face="Menlo" color="#a9b7c6" size="3">() {<br/>    </font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">this</span><font
        face="Menlo" color="#a9b7c6" size="3">.</font><span
        style="color: rgb(152, 118, 170); font-family: Menlo; font-size: 9.8pt;">dirtyComponentsLength </span><font
        face="Menlo" color="#a9b7c6" size="3">= dirtyComponents.</font><span
        style="color: rgb(152, 118, 170); font-family: Menlo; font-size: 9.8pt;">length</span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">;<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">  </span><font face="Menlo" color="#a9b7c6"
                                                                                               size="3">}</font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">,<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">  </span><span
        style="color: rgb(255, 198, 109); font-family: Menlo; font-size: 9.8pt;">close</span><font face="Menlo"
                                                                                                   color="#a9b7c6"
                                                                                                   size="3">: </font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">function</span><font
        face="Menlo" color="#a9b7c6" size="3">() {<br/>    </font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">if </span><font
        face="Menlo" color="#a9b7c6" size="3">(</font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">this</span><font
        face="Menlo" color="#a9b7c6" size="3">.</font><span
        style="color: rgb(152, 118, 170); font-family: Menlo; font-size: 9.8pt;">dirtyComponentsLength </span><font
        face="Menlo" color="#a9b7c6" size="3">!== dirtyComponents.</font><span
        style="color: rgb(152, 118, 170); font-family: Menlo; font-size: 9.8pt;">length</span><font face="Menlo"
                                                                                                    color="#a9b7c6" size="3">) {<br/>      </font><span
        style="color: rgb(128, 128, 128); font-family: Menlo; font-size: 9.8pt;">// Additional updates were enqueued by componentDidUpdate handlers or<br/></span><span
        style="color: rgb(128, 128, 128); font-family: Menlo; font-size: 9.8pt;">      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run<br/></span><span
        style="color: rgb(128, 128, 128); font-family: Menlo; font-size: 9.8pt;">      // these new updates so that if A's componentDidUpdate calls setState on<br/></span><span
        style="color: rgb(128, 128, 128); font-family: Menlo; font-size: 9.8pt;">      // B, B will update before the callback A's updater provided when calling<br/></span><font
        face="Menlo" color="#808080" size="3">      // setState.在close之前再检查一遍</font><font face="Menlo" color="#808080">dirtyComponent</font><font
        face="Menlo" color="#808080" size="3">是否有新的要更新的组件，有则更新，上面注释中将的场景应该是比如在A组件的setState传入了第二个参数回调函数，如果在A的componentDidUpdate中调用了setState改变了它包含的B组件的状态（这里假设只改变B 的状态），为了保证回调函数能访问到更新后的B组件，继续执行dirtyComponent中后插入的组件（B）然后更新B组件<br/></font><span
        style="color: rgb(128, 128, 128); font-family: Menlo; font-size: 9.8pt;">      </span><font face="Menlo"
                                                                                                    color="#a9b7c6" size="3">dirtyComponents.</font><span
        style="color: rgb(255, 198, 109); font-family: Menlo; font-size: 9.8pt;">splice</span><font face="Menlo"
                                                                                                    color="#a9b7c6"
                                                                                                    size="3">(</font><span
        style="color: rgb(104, 151, 187); font-family: Menlo; font-size: 9.8pt;">0</span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">, </span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">this</span><font
        face="Menlo" color="#a9b7c6" size="3">.</font><span
        style="color: rgb(152, 118, 170); font-family: Menlo; font-size: 9.8pt;">dirtyComponentsLength</span><font
        face="Menlo" color="#a9b7c6" size="3">)</font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">;<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">      </span><span
        style="color: rgb(255, 198, 109); font-family: Menlo; font-size: 9.8pt;">flushBatchedUpdates</span><font face="Menlo"
                                                                                                                 color="#a9b7c6"
                                                                                                                 size="3">()</font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">;<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">    </span><font face="Menlo" color="#a9b7c6"
                                                                                                 size="3">} </font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">else </span><font
        face="Menlo" color="#a9b7c6" size="3">{<br/>      dirtyComponents.</font><span
        style="color: rgb(152, 118, 170); font-family: Menlo; font-size: 9.8pt;">length </span><font face="Menlo"
                                                                                                     color="#a9b7c6" size="3">= </font><span
        style="color: rgb(104, 151, 187); font-family: Menlo; font-size: 9.8pt;">0</span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">;<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">    </span><font face="Menlo" color="#a9b7c6"
                                                                                                 size="3">}<br/>  }</font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">,<br/></span><font face="Menlo"
                                                                                                   color="#a9b7c6"
                                                                                                   size="3">}</font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">;<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;"><br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">var </span><font
        face="Menlo" color="#a9b7c6" size="3">TRANSACTION_WRAPPERS = [NESTED_UPDATES]</font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">;<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;"><br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">function </span><span
        style="color: rgb(255, 198, 109); font-family: Menlo; font-size: 9.8pt;">ReactUpdatesFlushTransaction</span><font
        face="Menlo" color="#a9b7c6" size="3">() {<br/>  </font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">this</span><font
        face="Menlo" color="#a9b7c6" size="3">.</font><span
        style="color: rgb(255, 198, 109); font-family: Menlo; font-size: 9.8pt;">reinitializeTransaction</span><font
        face="Menlo" color="#a9b7c6" size="3">()</font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">;<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">  </span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">this</span><font
        face="Menlo" color="#a9b7c6" size="3">.</font><span
        style="color: rgb(152, 118, 170); font-family: Menlo; font-size: 9.8pt;">dirtyComponentsLength </span><font
        face="Menlo" color="#a9b7c6" size="3">= </font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">null</span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">;<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">  </span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">this</span><font
        face="Menlo" color="#a9b7c6" size="3">.</font><span
        style="color: rgb(152, 118, 170); font-family: Menlo; font-size: 9.8pt;">reconcileTransaction </span><font
        face="Menlo" color="#a9b7c6" size="3">= ReactUpdates.</font><span
        style="color: rgb(152, 118, 170); font-family: Menlo; font-size: 9.8pt;">ReactReconcileTransaction</span><font
        face="Menlo" color="#a9b7c6" size="3">.</font><span
        style="color: rgb(255, 198, 109); font-family: Menlo; font-size: 9.8pt;">getPooled</span><font face="Menlo"
                                                                                                       color="#a9b7c6"
                                                                                                       size="3">(<br/>    </font><span
        style="color: rgb(128, 128, 128); font-family: Menlo; font-size: 9.8pt;">/* useCreateElement */ </span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">true<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">  </span><font face="Menlo"
                                                                                                                  color="#a9b7c6"
                                                                                                                  size="3">)</font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">;<br/></span><font face="Menlo"
                                                                                                   color="#a9b7c6"
                                                                                                   size="3">}<br/><br/>Object.</font><span
        style="color: rgb(255, 198, 109); font-family: Menlo; font-size: 9.8pt;">assign</span><font face="Menlo"
                                                                                                    color="#a9b7c6" size="3">(<br/>  </font><span
        style="color: rgb(255, 198, 109); font-family: Menlo; font-size: 9.8pt;">ReactUpdatesFlushTransaction</span><font
        face="Menlo" color="#a9b7c6" size="3">.</font><span
        style="color: rgb(152, 118, 170); font-family: Menlo; font-size: 9.8pt;">prototype</span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">,<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">  </span><font face="Menlo" color="#a9b7c6"
                                                                                               size="3">Transaction</font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">,<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">  </span><font face="Menlo" color="#a9b7c6"
                                                                                               size="3">{<br/>    </font><span
        style="color: rgb(255, 198, 109); font-family: Menlo; font-size: 9.8pt;">getTransactionWrappers</span><font
        face="Menlo" color="#a9b7c6" size="3">: </font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">function</span><font
        face="Menlo" color="#a9b7c6" size="3">() { //这里将wapper加到事务中<br/>      </font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt; font-weight: bold;">return </span><font
        face="Menlo" color="#a9b7c6" size="3">TRANSACTION_WRAPPERS</font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">;<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">    </span><font face="Menlo" color="#a9b7c6"
                                                                                                 size="3">}</font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">,<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">    //略去其他……<br/></span><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">  </span><font face="Menlo" color="#a9b7c6"
                                                                                               size="3">}<br/>)</font><span
        style="color: rgb(204, 120, 50); font-family: Menlo; font-size: 9.8pt;">;<br/></span><font face="Menlo"
                                                                                                   color="#a9b7c6" size="3"
/></pre>
    现在我们的更新事务结构如下图所示：
</div>
<div><img
        src="/images/2017-02-14/FE612576-70BB-4B9C-9343-07DFAC12DCB4.png"
        height="690" width="1766"/><br/></div>
<div>重点看下runBatchedUpdate方法是如何更新组件的。</div>
<div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.8pt;"><br/><span
        style="color:#cc7832;font-weight:bold;">function </span><span style="color:#ffc66d;">runBatchedUpdates</span>(transaction) {<br/>  <span
        style="color:#cc7832;font-weight:bold;">var </span>len = transaction.<span style="color:#9876aa;">dirtyComponentsLength</span><span
        style="color:#cc7832;">;</span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span
        style="color:#808080;">// Since reconciling a component higher in the owner hierarchy usually (not<br/></span><span
        style="color:#808080;">  // always -- see shouldComponentUpdate()) will reconcile children, reconcile<br/></span><span
        style="color:#808080;">  // them before their children by sorting the array.<br/></span><span
        style="color:#808080;">  </span>dirtyComponents.<span style="color:#ffc66d;">sort</span>(<span style="color:#ffc66d;">mountOrderComparator</span>)<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span
        style="color:#cc7832;">  </span><span style="color:#808080;">// Any updates enqueued while reconciling must be performed after this entire<br/></span><span
        style="color:#808080;">  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and<br/></span><span
        style="color:#808080;">  // C, B could update twice in a single batch if C's render enqueues an update<br/></span><span
        style="color:#808080;">  // to B (since B would have already updated, we should skip it, and the only<br/></span><span
        style="color:#808080;">  // way we can know to do so is by checking the batch counter).<br/></span><span
        style="color:#808080;">  </span>updateBatchNumber++<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span
        style="color:#cc7832;font-weight:bold;">for </span>(<span style="color:#cc7832;font-weight:bold;">var </span>i = <span
        style="color:#6897bb;">0</span><span style="color:#cc7832;">; </span>i &lt; len<span style="color:#cc7832;">; </span>i++) {<br/>    <span
        style="color:#808080;">// If a component is unmounted before pending changes apply, it will still<br/></span><span
        style="color:#808080;">    // be here, but we assume that it has cleared its _pendingCallbacks and<br/></span><span
        style="color:#808080;">    // that performUpdateIfNecessary is a noop.<br/></span><span
        style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>component = dirtyComponents[i]<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">   </span><br/>    ReactReconciler.<span
        style="color:#ffc66d;">performUpdateIfNecessary</span>(<br/>      component<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">      </span>transaction.<span
        style="color:#9876aa;">reconcileTransaction</span><span style="color:#cc7832;">,<br/></span><span
        style="color:#cc7832;">      </span>updateBatchNumber<br/>    )<span style="color:#cc7832;">;<br/></span><br/>  }<br/>}
</pre>
</div>
<div>遍历dirtyComponent数组，对每个component实例调用performUpdateIfNecessary，</div>
<div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span
        style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`<br/></span><span
        style="color:#629755;font-style:italic;"> * is set, update the component.<br/></span><span
        style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * </span><span
        style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span
        style="color:#629755;font-style:italic;">{ReactReconcileTransaction} transaction<br/></span><span
        style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@internal<br/></span><span
        style="color:#629755;font-weight:bold;font-style:italic;"/><span
        style="color:#629755;font-style:italic;">*/<br/></span>performUpdateIfNecessary: <span
        style="color:#cc7832;font-weight:bold;">function</span>(transaction) {<br/>  <span
        style="color:#cc7832;font-weight:bold;">if </span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span
        style="color:#9876aa;">_pendingElement </span>!= <span style="color:#cc7832;font-weight:bold;">null</span>) { //如果渲染的ReactElement发生变化更新渲染的ReactElement<br/>    ReactReconciler.<span
        style="color:#ffc66d;">receiveComponent</span>(<br/>      <span
        style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">,<br/></span><span
        style="color:#cc7832;">      </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span
        style="color:#9876aa;">_pendingElement</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">      </span>transaction<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">      </span><span
        style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_context<br/></span><span
        style="color:#9876aa;">    </span>)<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">  </span>} <span style="color:#cc7832;font-weight:bold;">else if </span>(<span
        style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_pendingStateQueue </span>!== <span
        style="color:#cc7832;font-weight:bold;">null </span>|| <span style="color:#cc7832;font-weight:bold;">this</span>.<span
        style="color:#9876aa;">_pendingForceUpdate</span>) {//如果只是状态发生变化<br/>    <span
        style="color:#cc7832;font-weight:bold;">this</span>.<span
        style="color:#9876aa;">updateComponent</span>( //这里调用diff算法<br/>      transaction<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">      </span><span
        style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_currentElement</span><span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">      </span><span
        style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_currentElement</span><span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">      </span><span
        style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_context</span><span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">      </span><span
        style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_context<br/></span><span
        style="color:#9876aa;">    </span>)<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">  </span>} <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>    <span
        style="color:#cc7832;font-weight:bold;">var </span>callbacks = <span
        style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_pendingCallbacks</span><span
        style="color:#cc7832;">; <br/></span><span style="color:#cc7832;">    </span><span
        style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_pendingCallbacks </span>= <span
        style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">    </span><span
        style="color:#cc7832;font-weight:bold;">if </span>(callbacks) {<br/>      <span
        style="color:#cc7832;font-weight:bold;">for </span>(<span style="color:#cc7832;font-weight:bold;">var </span>j = <span
        style="color:#6897bb;">0</span><span style="color:#cc7832;">; </span>j &lt; callbacks.<span style="color:#9876aa;">length</span><span
        style="color:#cc7832;">; </span>j++) {<br/>        transaction.<span style="color:#ffc66d;">getReactMountReady</span>().<span
        style="color:#ffc66d;">enqueue</span>(<br/>          callbacks[j]<span style="color:#cc7832;">,<br/></span><span
        style="color:#cc7832;">          </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span
        style="color:#ffc66d;">getPublicInstance</span>()<br/>        )<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">      </span>}<br/>    }<br/>    <span
        style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_updateBatchNumber </span>= <span
        style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">  </span>}<br/>}<span style="color:#cc7832;">,<br/></span>
</pre>
</div>
<div><br/></div>
<div>所以整个setState执行流程参见下图：</div>
<div><br/></div>
<div><img
        src="/images/2017-02-14/xxx.png"
        height="656" width="614"/><br/></div>
<div>diff算法部分源码在（src/renderers/shared/stack/reconciler/ReactMultiChild.js）</div>
<div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span
        style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * </span><span
        style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span
        style="color:#629755;font-style:italic;">{?object} nextNestedChildrenElements Nested child element maps.<br/></span><span
        style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span
        style="color:#629755;font-style:italic;">{ReactReconcileTransaction} transaction<br/></span><span
        style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@final<br/></span><span
        style="color:#629755;font-weight:bold;font-style:italic;"/><span
        style="color:#629755;font-style:italic;">* </span><span style="color:#629755;font-weight:bold;font-style:italic;">@protected<br/></span><span
        style="color:#629755;font-weight:bold;font-style:italic;"/><span
        style="color:#629755;font-style:italic;">*/<br/></span><span style="color:#ffc66d;">_updateChildren</span>: <span
        style="color:#cc7832;font-weight:bold;">function</span>(nextNestedChildrenElements<span
        style="color:#cc7832;">, </span>transaction<span style="color:#cc7832;">, </span>context) {<br/>  <span
        style="color:#cc7832;font-weight:bold;">var </span>prevChildren = <span
        style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_renderedChildren</span><span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span
        style="color:#cc7832;font-weight:bold;">var </span>removedNodes = {}<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>mountImages = []<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span
        style="color:#cc7832;font-weight:bold;">var </span>nextChildren = <span
        style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_reconcilerUpdateChildren</span>(  &lt;————— 1 下面详细介绍（注意mountImages和removedNode都是在这个函数赋值的）<br/>    prevChildren<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>nextNestedChildrenElements<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>mountImages<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>removedNodes<span style="color:#cc7832;">,<br/></span><span
        style="color:#cc7832;">    </span>transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>context<br/>  )<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span
        style="color:#cc7832;font-weight:bold;">if </span>(!nextChildren &amp;&amp; !prevChildren) {<br/>    <span
        style="color:#cc7832;font-weight:bold;">return</span><span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">  </span>}<br/>  <span style="color:#cc7832;font-weight:bold;">var </span>updates = <span
        style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>name<span
        style="color:#cc7832;">;//以下是diff算法部分，讲解参见博客链接<br/></span><span style="color:#cc7832;">  </span><span
        style="color:#808080;">// `nextIndex` will increment for each child in `nextChildren`, but<br/></span><span
        style="color:#808080;">  // `lastIndex` will be the last index visited in `prevChildren`.<br/></span><span
        style="color:#808080;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>nextIndex = <span
        style="color:#6897bb;">0</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span
        style="color:#cc7832;font-weight:bold;">var </span>lastIndex = <span style="color:#6897bb;">0</span><span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#808080;">// `nextMountIndex` will increment for each newly mounted child.<br/></span><span
        style="color:#808080;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>nextMountIndex = <span
        style="color:#6897bb;">0</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span
        style="color:#cc7832;font-weight:bold;">var </span>lastPlacedNode = <span
        style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">for </span>(name <span
        style="color:#cc7832;font-weight:bold;">in </span>nextChildren) {<br/>    <span
        style="color:#cc7832;font-weight:bold;">if </span>(!nextChildren.<span style="color:#ffc66d;">hasOwnProperty</span>(name)) {<br/>      <span
        style="color:#cc7832;font-weight:bold;">continue</span><span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">    </span>}<br/>    <span style="color:#cc7832;font-weight:bold;">var </span>prevChild = prevChildren &amp;&amp; prevChildren[name]<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span
        style="color:#cc7832;font-weight:bold;">var </span>nextChild = nextChildren[name]<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span
        style="color:#cc7832;font-weight:bold;">if </span>(prevChild === nextChild) {<br/>      updates = <span
        style="color:#ffc66d;">enqueue</span>(<br/>        updates<span style="color:#cc7832;">,<br/></span><span
        style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span
        style="color:#ffc66d;">moveChild</span>(prevChild<span style="color:#cc7832;">, </span>lastPlacedNode<span
        style="color:#cc7832;">, </span>nextIndex<span style="color:#cc7832;">, </span>lastIndex)<br/>      )<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>lastIndex = <span
        style="color:#9876aa;">Math</span>.<span style="color:#ffc66d;">max</span>(prevChild.<span style="color:#9876aa;">_mountIndex</span><span
        style="color:#cc7832;">, </span>lastIndex)<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">      </span>prevChild.<span style="color:#9876aa;">_mountIndex </span>= nextIndex<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>} <span
        style="color:#cc7832;font-weight:bold;">else </span>{<br/>      <span
        style="color:#cc7832;font-weight:bold;">if </span>(prevChild) {<br/>        <span style="color:#808080;">// Update `lastIndex` before `_mountIndex` gets unset by unmounting.<br/></span><span
        style="color:#808080;">        </span>lastIndex = <span style="color:#9876aa;">Math</span>.<span
        style="color:#ffc66d;">max</span>(prevChild.<span style="color:#9876aa;">_mountIndex</span><span
        style="color:#cc7832;">, </span>lastIndex)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span
        style="color:#808080;">// The `removedNodes` loop below will actually remove the child.<br/></span><span
        style="color:#808080;">      </span>}<br/>      <span style="color:#808080;">// The child must be instantiated before it's mounted.<br/></span><span
        style="color:#808080;">      </span>updates = <span style="color:#ffc66d;">enqueue</span>(<br/>        updates<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span><span
        style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_mountChildAtIndex</span>(<br/>          nextChild<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">          </span>mountImages[nextMountIndex]<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">          </span>lastPlacedNode<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">          </span>nextIndex<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">          </span>transaction<span
        style="color:#cc7832;">,<br/></span><span
        style="color:#cc7832;">          </span>context<br/>        )<br/>      )<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>nextMountIndex++<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/>    nextIndex++<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>lastPlacedNode = ReactReconciler.<span
        style="color:#ffc66d;">getHostNode</span>(nextChild)<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">  </span>}<br/>  <span
        style="color:#808080;">// Remove children that are no longer present.<br/></span><span
        style="color:#808080;">  </span><span style="color:#cc7832;font-weight:bold;">for </span>(name <span
        style="color:#cc7832;font-weight:bold;">in </span>removedNodes) {<br/>    <span
        style="color:#cc7832;font-weight:bold;">if </span>(removedNodes.<span style="color:#ffc66d;">hasOwnProperty</span>(name)) {<br/>      updates = <span
        style="color:#ffc66d;">enqueue</span>(<br/>        updates<span style="color:#cc7832;">,<br/></span><span
        style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span
        style="color:#ffc66d;">_unmountChild</span>(prevChildren[name]<span style="color:#cc7832;">, </span>removedNodes[name])<br/>      )<span
        style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/>  }<br/>  <span
        style="color:#cc7832;font-weight:bold;">if </span>(updates) {<br/>    <span style="color:#ffc66d;">processQueue</span>(<span
        style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">, </span>updates)<span
        style="color:#cc7832;">;//注意这里将上面比较后缓存的变更进行处理更新dom树，使所有变更在浏览器中得以展现，代码参见（src/<font
        style="font-size: 12px; color: rgb(204, 120, 50); font-family: Menlo;">renderers/dom/stack/client/DOMChildrenOperations.js</font>）的processUpdate<br/></span><span
        style="color:#cc7832;">  </span>}<br/>  <span style="color:#cc7832;font-weight:bold;">this</span>.<span
        style="color:#9876aa;">_renderedChildren </span>= nextChildren<span style="color:#cc7832;">;<br/></span><br/>}<span
        style="color:#cc7832;">,</span>
</pre>
    React在执行diff算法之前先做了两件事情：
</div>
<div>
    <ol start="1">
        <li>将新的ReactElement结构树（可能包含很多层）’拍平’，以{ key：xx，value：element}方式返回</li>
        <li>遍历上一步生成的key——ReactElement映射和原有的key——ReactComponent实例映射做比较，新建或删除ReactComponent。</li>
    </ol>
</div>
<div>经过上面两个步骤生成了新的key——ReactComponent实例，和原有的key——ReactComponent映射进行diff算法。</div>
<div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span
        style="color:#ffc66d;">_reconcilerUpdateChildren</span>: <span style="color:#cc7832;font-weight:bold;">function</span>(<br/>  prevChildren<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>nextNestedChildrenElements<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>mountImages<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>removedNodes<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>transaction<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>context<br/>) {<br/>  <span
        style="color:#cc7832;font-weight:bold;">var </span>nextChildren<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>selfDebugID = <span
        style="color:#6897bb;">0</span><span style="color:#cc7832;">;<br/></span> //第一步：调用（src/<font
        style="font-size: 12px; color: rgb(169, 183, 198); font-family: Menlo;">shared/utils/traverseAllChildren.js</font>）对子节点进行深度优先遍历，同时根据子节点所在的层级按照一定命名规则生成唯一key存在object中，这样虽然所有树状结构的子节点被’拍平’存储，但是能保证在diff操作的时候同一层级的子节点进行比较（即连个map中key相同的子节点一定在同一层）<br/>  nextChildren = flattenChildren(nextNestedChildrenElements<span
        style="color:#cc7832;">, </span>selfDebugID)<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">  </span>ReactChildReconciler.<span style="color:#ffc66d;">updateChildren</span>( //第二步：参见下面详细介绍<br/>    prevChildren<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>nextChildren<span style="color:#cc7832;">,<br/></span><span
        style="color:#cc7832;">    </span>mountImages<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>removedNodes<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>transaction<span
        style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span><span
        style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">,<br/></span><span
        style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span
        style="color:#9876aa;">_hostContainerInfo</span><span style="color:#cc7832;">,<br/></span><span
        style="color:#cc7832;">    </span>context<span style="color:#cc7832;">,<br/></span><span
        style="color:#cc7832;">    </span>selfDebugID<br/>  )<span style="color:#cc7832;">;<br/></span><span
        style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">return </span>nextChildren<span
        style="color:#cc7832;">;<br/></span>}<span style="color:#cc7832;">,</span>
</pre>
    <div>
		<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span
                style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Updates the rendered children and returns a new set of children.<br/></span><span
                style="color:#629755;font-style:italic;"> *<br/></span><span
                style="color:#629755;font-style:italic;"> * </span><span
                style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span
                style="color:#629755;font-style:italic;">{?object} prevChildren Previously initialized set of children.<br/></span><span
                style="color:#629755;font-style:italic;"> * </span><span
                style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span
                style="color:#629755;font-style:italic;">{?object} nextChildren Flat child element maps.<br/></span><span
                style="color:#629755;font-style:italic;"> * </span><span
                style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span
                style="color:#629755;font-style:italic;">{ReactReconcileTransaction} transaction<br/></span><span
                style="color:#629755;font-style:italic;"> * </span><span
                style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span
                style="color:#629755;font-style:italic;">{object} context<br/></span><span
                style="color:#629755;font-style:italic;"> * </span><span
                style="color:#629755;font-weight:bold;font-style:italic;">@return </span><span
                style="color:#629755;font-style:italic;">{?object} A new set of child instances.<br/></span><span
                style="color:#629755;font-style:italic;"> * </span><span
                style="color:#629755;font-weight:bold;font-style:italic;">@internal<br/></span><span
                style="color:#629755;font-weight:bold;font-style:italic;"/><span style="color:#629755;font-style:italic;">*/<br/></span><span
                style="color:#ffc66d;">updateChildren</span>: <span style="color:#cc7832;font-weight:bold;">function</span>(<br/>  prevChildren<span
                style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>nextChildren<span
                style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>mountImages<span style="color:#cc7832;">,<br/></span><span
                style="color:#cc7832;">  </span>removedNodes<span style="color:#cc7832;">,<br/></span><span
                style="color:#cc7832;">  </span>transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>hostParent<span
                style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>hostContainerInfo<span
                style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>context<span
                style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>selfDebugID <span
                style="color:#808080;">// 0 in production and for roots<br/></span>) {<br/>  <span style="color:#808080;">// We currently don't have a way to track moves here but if we use iterators<br/></span><span
                style="color:#808080;">  // instead of for..in we can zip the iterators and check if an item has<br/></span><span
                style="color:#808080;">  // moved.<br/></span><span style="color:#808080;">  // </span><span
                style="color:#a8c023;font-style:italic;">TODO: If nothing has changed, return the prevChildren object so that we<br/></span><span
                style="color:#a8c023;font-style:italic;">  </span><span style="color:#808080;">// can quickly bailout if nothing has changed.<br/></span><span
                style="color:#808080;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(!nextChildren &amp;&amp; !prevChildren) {<br/>    <span
                style="color:#cc7832;font-weight:bold;">return</span><span style="color:#cc7832;">;<br/></span><span
                style="color:#cc7832;">  </span>}<br/>  <span style="color:#cc7832;font-weight:bold;">var </span>name<span
                style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span
                style="color:#cc7832;font-weight:bold;">var </span>prevChild<span style="color:#cc7832;">;<br/></span><span
                style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">for </span>(name <span
                style="color:#cc7832;font-weight:bold;">in </span>nextChildren) {<br/>    <span
                style="color:#cc7832;font-weight:bold;">if </span>(!nextChildren.<span
                style="color:#ffc66d;">hasOwnProperty</span>(name)) {<br/>      <span style="color:#cc7832;font-weight:bold;">continue</span><span
                style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/>    prevChild = prevChildren &amp;&amp; prevChildren[name]<span
                style="color:#cc7832;">; //如果旧映射里找到对应的ReactComponent实例<br/></span><span style="color:#cc7832;">    </span><span
                style="color:#cc7832;font-weight:bold;">var </span>prevElement = prevChild &amp;&amp; prevChild.<span
                style="color:#9876aa;">_currentElement</span><span style="color:#cc7832;">;<br/></span><span
                style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>nextElement = nextChildren[name]<span
                style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span
                style="color:#cc7832;font-weight:bold;">if </span>(prevChild != <span
                style="color:#cc7832;font-weight:bold;">null </span>&amp;&amp;<br/>        shouldUpdateReactComponent(prevElement<span
                style="color:#cc7832;">, </span>nextElement)) {//取出实例中的ReactElement与新的做比较，如果类型相同调用实例更新函数<br/>      ReactReconciler.<span
                style="color:#ffc66d;">receiveComponent</span>(<br/>        prevChild<span style="color:#cc7832;">, </span>nextElement<span
                style="color:#cc7832;">, </span>transaction<span style="color:#cc7832;">, </span>context<br/>      )<span
                style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>nextChildren[name] = prevChild<span
                style="color:#cc7832;">; <br/></span><span style="color:#cc7832;">    </span>} <span
                style="color:#cc7832;font-weight:bold;">else </span>{ //否则清理旧的ReactComponent实例，加入到removeNodes映射中，初始化新实例加入映射中，调用新实例的mountComponent获得对应的渲染markup加入到<font
                style="font-family: Menlo; background-color: rgb(43, 43, 43); font-size: 12px; color: rgb(169, 183, 198);">mountImages 。<font
                style="font-family: Menlo; background-color: rgb(43, 43, 43); font-size: 12px; color: rgb(169, 183, 198);">removeNodes映射和mountImage映射在diff算法执行过程中加入到更新队列然后批量更新dom。</font></font><br/>      <span
                style="color:#cc7832;font-weight:bold;">if </span>(<br/>        !ReactFeatureFlags.<span style="color:#9876aa;">prepareNewChildrenBeforeUnmountInStack </span>&amp;&amp;<br/>        prevChild<br/>      ) {<br/>        removedNodes[name] = ReactReconciler.<span
                style="color:#ffc66d;">getHostNode</span>(prevChild)<span style="color:#cc7832;">;<br/></span><span
                style="color:#cc7832;">        </span>ReactReconciler.<span style="color:#ffc66d;">unmountComponent</span>(<br/>          prevChild<span
                style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">          </span><span
                style="color:#cc7832;font-weight:bold;">false</span><span style="color:#cc7832;">, </span><span
                style="color:#808080;">/* safely */<br/></span><span style="color:#808080;">          </span><span
                style="color:#cc7832;font-weight:bold;">false </span><span
                style="color:#808080;">/* skipLifecycle */<br/></span><span style="color:#808080;">        </span>)<span
                style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>}<br/>      <span
                style="color:#808080;">// The child must be instantiated before it's mounted.<br/></span><span
                style="color:#808080;">      </span><span style="color:#cc7832;font-weight:bold;">var </span>nextChildInstance = instantiateReactComponent(nextElement<span
                style="color:#cc7832;">, </span><span style="color:#cc7832;font-weight:bold;">true</span>)<span
                style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>nextChildren[name] = nextChildInstance<span
                style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span><span style="color:#808080;">// Creating mount image now ensures refs are resolved in right order<br/></span><span
                style="color:#808080;">      // (see <a href="https://github.com/facebook/react/pull/7101">https://github.com/facebook/react/pull/7101</a> for explanation).<br/></span><span
                style="color:#808080;">      </span><span style="color:#cc7832;font-weight:bold;">var </span>nextChildMountImage = ReactReconciler.<span
                style="color:#ffc66d;">mountComponent</span>(<br/>        nextChildInstance<span
                style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>transaction<span
                style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>hostParent<span
                style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>hostContainerInfo<span
                style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>context<span
                style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>selfDebugID<br/>      )<span
                style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>mountImages.<span
                style="color:#ffc66d;">push</span>(nextChildMountImage)<span style="color:#cc7832;">;<br/></span><span
                style="color:#cc7832;">      </span><span style="color:#cc7832;font-weight:bold;">if </span>(<br/>        ReactFeatureFlags.<span
                style="color:#9876aa;">prepareNewChildrenBeforeUnmountInStack </span>&amp;&amp;<br/>        prevChild<br/>      ) {<br/>        removedNodes[name] = ReactReconciler.<span
                style="color:#ffc66d;">getHostNode</span>(prevChild)<span style="color:#cc7832;">;<br/></span><span
                style="color:#cc7832;">        </span>ReactReconciler.<span style="color:#ffc66d;">unmountComponent</span>(<br/>          prevChild<span
                style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">          </span><span
                style="color:#cc7832;font-weight:bold;">false</span><span style="color:#cc7832;">, </span><span
                style="color:#808080;">/* safely */<br/></span><span style="color:#808080;">          </span><span
                style="color:#cc7832;font-weight:bold;">false </span><span
                style="color:#808080;">/* skipLifecycle */<br/></span><span style="color:#808080;">        </span>)<span
                style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>}<br/>    }<br/>  }<br/>  <span
                style="color:#808080;">// Unmount children that are no longer present.<br/></span><span
                style="color:#808080;">  </span><span style="color:#cc7832;font-weight:bold;">for </span>(name <span
                style="color:#cc7832;font-weight:bold;">in </span>prevChildren) {<br/>    <span
                style="color:#cc7832;font-weight:bold;">if </span>(prevChildren.<span style="color:#ffc66d;">hasOwnProperty</span>(name) &amp;&amp;<br/>        !(nextChildren &amp;&amp; nextChildren.<span
                style="color:#ffc66d;">hasOwnProperty</span>(name))) {<br/>      prevChild = prevChildren[name]<span
                style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>removedNodes[name] = ReactReconciler.<span
                style="color:#ffc66d;">getHostNode</span>(prevChild)<span style="color:#cc7832;">;<br/></span><span
                style="color:#cc7832;">      </span>ReactReconciler.<span style="color:#ffc66d;">unmountComponent</span>(<br/>        prevChild<span
                style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span><span
                style="color:#cc7832;font-weight:bold;">false</span><span style="color:#cc7832;">, </span><span
                style="color:#808080;">/* safely */<br/></span><span style="color:#808080;">        </span><span
                style="color:#cc7832;font-weight:bold;">false </span><span
                style="color:#808080;">/* skipLifecycle */<br/></span><span style="color:#808080;">      </span>)<span
                style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/>  }<br/>}<span
                style="color:#cc7832;">,</span></pre>
    </div>
    <div><br/></div>
    <div>diff算法原理详解参见：<br/></div>
</div>
<div><a href="https://zhuanlan.zhihu.com/p/20346379?refer=purerender">https://zhuanlan.zhihu.com/p/20346379?refer=purerender</a> 或《深入React技术栈》3.5章（可以找我借）讲得很详细。<br/>
</div>
<div><br/></div>
