---
layout: post
title:  react源码学习——Virtual Dom和渲染、更新原理s
date:   2017-01-20 08:43:59
author: Lily
categories: frontend
tags:
- react
- 源码解读
---

<div><span style="color: rgb(68, 68, 68); font-family: 'Helvetica Neue', Helvetica, 'Lucida Grande', Arial, 'Hiragino Sans GB', 微软雅黑, 'WenQuanYi Micro Hei', STHeiti, SimSun, sans-serif; font-size: 14px; orphans: 2; widows: 2;">前端开发过程中，更新页面的数据、样式等操作都要操作dom，而复杂的dom操作通常是产品性能瓶颈原因之一，为此React引入了Virtual Dom的概念，Virtual Dom其实是用js实现了一套dom api，包括虚拟dom模型、生命周期管理、diff算法等。React会将传入的JSX片段转化成虚拟dom节点，当数据更新时，通过diff算法找到要变更的dom节点，并只对变化的部分进行实际的浏览器dom更新，而不是重新渲染整个dom树。下面我们结合组件渲染流程结合源码介绍一下React如何创建虚拟节点，以及如何渲染、更新节点的整个流程。</span><br/></div><div><span style="color: rgb(68, 68, 68); font-family: 'Helvetica Neue', Helvetica, 'Lucida Grande', Arial, 'Hiragino Sans GB', 微软雅黑, 'WenQuanYi Micro Hei', STHeiti, SimSun, sans-serif; font-size: 14px; orphans: 2; widows: 2;">——以下代码是React v15.4.2版本——<br/></span></div><div>React项目渲染组件的方法是：ReactDom.render，将父组件连带所有包含在内的子组件渲染出来。render方法最终调用了 src/renderers/dom/stack/client/ReactMount.js 的render方法。</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Renders a React component into the DOM in the supplied `container`.<br/></span><span style="color:#629755;font-style:italic;"> * See <a href="https://facebook.github.io/react/docs/react-dom.html#render">https://facebook.github.io/react/docs/react-dom.html#render</a><br/></span><span style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * If the React component was previously rendered into `container`, this will<br/></span><span style="color:#629755;font-style:italic;"> * perform an update on it and only mutate the DOM as necessary to reflect the<br/></span><span style="color:#629755;font-style:italic;"> * latest React component.<br/></span><span style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactElement} nextElement Component element to render.<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{DOMElement} container DOM element to render into.<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{?function} callback function triggered on completion<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@return </span><span style="color:#629755;font-style:italic;">{ReactComponent} Component instance rendered in `container`.<br/></span><span style="color:#629755;font-style:italic;"> */<br/></span><span style="color:#ffc66d;">render</span>: <span style="color:#cc7832;font-weight:bold;">function</span>(nextElement<span style="color:#cc7832;">, </span>container<span style="color:#cc7832;">, </span>callback) {<br/>  <span style="color:#cc7832;font-weight:bold;">return </span>ReactMount.<span style="color:#ffc66d;">_renderSubtreeIntoContainer</span>(<span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">, </span>nextElement<span style="color:#cc7832;">, </span>container<span style="color:#cc7832;">, </span>callback)<span style="color:#cc7832;">;<br/></span>}<span style="color:#cc7832;">,</span></pre></div><div>注意这里第一个参数是ReactElement类型，通常为了可读性和开发效率我们传入JSX写的结构，最终会编译转换成调用React的createElement方法生成虚拟元素ReactElement结构传入render中。这里我们先看一下React.createElement做了哪些事情（src/isomorphic/classic/element/ReactElement.js）</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><br/><span style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Create and return a new ReactElement of the given type.<br/></span><span style="color:#629755;font-style:italic;"> * See <a href="https://facebook.github.io/react/docs/react-api.html#createelement">https://facebook.github.io/react/docs/react-api.html#createelement</a><br/></span><span style="color:#629755;font-style:italic;"> */<br/></span><span style="color:#ffc66d;">ReactElement</span>.<span style="color:#ffc66d;">createElement </span>= <span style="color:#cc7832;font-weight:bold;">function</span>(type<span style="color:#cc7832;">, </span>config<span style="color:#cc7832;">, </span>children) {<br/>    <span style="color:#cc7832;font-weight:bold;">var </span>propName<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;">// Reserved names are extracted<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>props = {}<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>key = <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>ref = <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>self = <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>source = <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(config != <span style="color:#cc7832;font-weight:bold;">null</span>) {<br/>        <span style="color:#cc7832;font-weight:bold;">if </span>(<span style="color:#ffc66d;">hasValidRef</span>(config)) {<br/>            ref = config.<span style="color:#9876aa;">ref</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>}<br/>        <span style="color:#cc7832;font-weight:bold;">if </span>(<span style="color:#ffc66d;">hasValidKey</span>(config)) {<br/>            key = <span style="color:#6a8759;">'' </span>+ config.key<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>}<br/><br/>        self = config.<span style="color:#9876aa;">__self </span>=== <span style="color:#9876aa;">undefined </span>? <span style="color:#cc7832;font-weight:bold;">null </span>: config.<span style="color:#9876aa;">__self</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>source = config.<span style="color:#9876aa;">__source </span>=== <span style="color:#9876aa;">undefined </span>? <span style="color:#cc7832;font-weight:bold;">null </span>: config.<span style="color:#9876aa;">__source</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#808080;">// config中的内容复制到props<br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">for </span>(propName <span style="color:#cc7832;font-weight:bold;">in </span>config) {<br/>            <span style="color:#cc7832;font-weight:bold;">if </span>(hasOwnProperty.<span style="color:#ffc66d;">call</span>(config<span style="color:#cc7832;">, </span>propName) &amp;&amp;<br/>                !RESERVED_PROPS.<span style="color:#ffc66d;">hasOwnProperty</span>(propName)) {<br/>                props[propName] = config[propName]<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span>}<br/>        }<br/>    }<br/><br/>    <span style="color:#808080;">//将第三个及之后的参数作为children赋值给props的children属性<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>childrenLength = arguments.<span style="color:#9876aa;">length </span>- <span style="color:#6897bb;">2</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(childrenLength === <span style="color:#6897bb;">1</span>) {<br/>        props.<span style="color:#9876aa;">children </span>= children<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>} <span style="color:#cc7832;font-weight:bold;">else if </span>(childrenLength &gt; <span style="color:#6897bb;">1</span>) {<br/>        <span style="color:#cc7832;font-weight:bold;">var </span>childArray = Array(childrenLength)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">for </span>(<span style="color:#cc7832;font-weight:bold;">var </span>i = <span style="color:#6897bb;">0</span><span style="color:#cc7832;">; </span>i &lt; childrenLength<span style="color:#cc7832;">; </span>i++) {<br/>            childArray[i] = arguments[i + <span style="color:#6897bb;">2</span>]<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>}<br/><br/>        props.<span style="color:#9876aa;">children </span>= childArray<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/><br/>    <span style="color:#808080;">// 如果某个props为空且存在默认props，赋值<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(type &amp;&amp; type.<span style="color:#9876aa;font-style:italic;">defaultProps</span>) {<br/>        <span style="color:#cc7832;font-weight:bold;">var </span>defaultProps = type.<span style="color:#9876aa;font-style:italic;">defaultProps</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">for </span>(propName <span style="color:#cc7832;font-weight:bold;">in </span>defaultProps) {<br/>            <span style="color:#cc7832;font-weight:bold;">if </span>(props[propName] === <span style="color:#9876aa;">undefined</span>) {<br/>                props[propName] = defaultProps[propName]<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span>}<br/>        }<br/>    }<br/><br/>    <span style="color:#cc7832;font-weight:bold;">return </span><span style="color:#ffc66d;">ReactElement</span>(<br/>        type<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>key<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>ref<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>self<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>source<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>ReactCurrentOwner.<span style="color:#9876aa;">current</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>props<br/>    )<span style="color:#cc7832;">;<br/></span>}<span style="color:#cc7832;">;</span>
</pre></div><div><br/></div><div>下面结合源码详细讲解整个渲染的过程。</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#ffc66d;">render</span>: <span style="color:#cc7832;font-weight:bold;">function</span>(nextElement<span style="color:#cc7832;">, </span>container<span style="color:#cc7832;">, </span>callback) {<br/>  <span style="color:#cc7832;font-weight:bold;">return </span>ReactMount.<span style="color:#ffc66d;">_renderSubtreeIntoContainer</span>(<span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">, </span>nextElement<span style="color:#cc7832;">, </span>container<span style="color:#cc7832;">, </span>callback)<span style="color:#cc7832;">;<br/></span>}<span style="color:#cc7832;">,</span>
</pre>去掉各种检查后的代码如下：</div><div>思路：首先获得dom container里原有的ReactElement，如果存在则将实际需要渲染的ReactElement（上一步用<font style="font-family: Menlo; font-size: 12px; background-color: rgb(43, 43, 43); color: rgb(128, 128, 128);">TopLevelWrapper</font>包裹的child）和新的ReactElement做比较（1），如果应该更新则更新组件（2），否则清空container内之前渲染的组件（3），生成新的根ReactComponent渲染到container中（4）。</div><div>主要流程图如下：<br/><img src="/images/2017-01-20/%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%9B%BE.png" height="558" width="650"/><br/></div><div><pre style="background-color: rgb(43, 43, 43);"><span style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">_renderSubtreeIntoContainer</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">: </font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">function</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(parentComponent</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">, </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">nextElement</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">, </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">container</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">, </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">callback) {</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);"><br/></span><pre style="font-family: Menlo; font-size: 9pt; background-color: rgb(43, 43, 43);"><span style="font-size: 9pt;"><font><pre style="background-color: rgb(43, 43, 43); font-family: Menlo; font-size: 9pt;">   <span style="color: rgb(128, 128, 128);">//nextElement外包一层react定义的TopLevelWrapper用于屏蔽各类组件的差异记录一些变量，比如顶层组件的计数<br/></span><span style="color: rgb(204, 120, 50); font-weight: bold;">   var </span><font color="#a9b7c6">nextWrappedElement = React.</font><span style="color: rgb(152, 118, 170);">createElement</span><font color="#a9b7c6">(<br/>     </font><span style="color: rgb(255, 198, 109);">TopLevelWrapper</span><span style="color: rgb(204, 120, 50);">,<br/></span><span style="color: rgb(204, 120, 50);">     </span><font color="#a9b7c6">{ </font><span style="color: rgb(152, 118, 170);">child</span><font color="#a9b7c6">: nextElement }<br/>   )</font>;</pre></font></span></pre><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">  </span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">var </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">nextContext = getContextForSubtree(parentComponent)</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;//本次调用返回null<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">  </span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">var </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">prevComponent = </font><span style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">getTopLevelWrapperInContainer</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(container)</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);"><br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">  </span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">if </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(prevComponent) {<br/>    </font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">var </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">prevWrappedElement = prevComponent.</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(152, 118, 170);">_currentElement</span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">    </span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">var </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">prevElement = prevWrappedElement.</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(152, 118, 170);">props</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">.child</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">    </span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">if </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(shouldUpdateReactComponent(prevElement</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">, </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">nextElement)) {      &lt;——— 1<br/>      </font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">var </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">publicInst = prevComponent.</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(152, 118, 170);">_renderedComponent</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">.</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">getPublicInstance</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">()</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">      </span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">var </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">updatedCallback = callback &amp;&amp; </font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">function</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">() {<br/>        callback.</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">call</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(publicInst)</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">      </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">}</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">      </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">ReactMount.</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">_updateRootComponent</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(   &lt;———— 2<br/>        prevComponent</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">,<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">        </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">nextWrappedElement</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">,<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">        </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">nextContext</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">,<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">        </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">container</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">,<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">        </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">updatedCallback<br/>      )</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">      </span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">return </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">publicInst</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">    </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">} </font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">else </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">{<br/>      ReactMount.</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">unmountComponentAtNode</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(container)</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;  <font style="font-family: Menlo; background-color: rgb(43, 43, 43); font-size: 12px; color: rgb(169, 183, 198);">&lt;———— 3</font><br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">    </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">}<br/>  }<br/><br/>  </font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">var </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">reactRootElement = </font><span style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">getReactRootElementInContainer</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(container)</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;//获得container节点的第一个dom子节点<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">  </span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">var </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">containerHasReactMarkup =<br/>    reactRootElement &amp;&amp; !!</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">internalGetID</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(reactRootElement)</font><font face="Menlo" color="#cc7832" size="2">; //判断这个dom子节点是不是React渲染的（React渲染的会有会有一个‘data-reacted’的attribute属性）<br/></font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">  </span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">var </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">containerHasNonRootReactChild = </font><span style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">hasNonRootReactChild</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(container)</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">; //判断container是否包含不是React根节点的React实例<br/></span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6"><br/>  </font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">var </span><font color="#a9b7c6"><font face="Menlo" size="2">shouldReuseMarkup =           //这里不太明白什么情况会重用markup，因为在’3’已经把container中的dom清空了，欢迎讨论<br/>    containerHasReactMarkup &amp;&amp;<br/>    !prevComponent &amp;&amp;<br/>    !containerHasNonRootReactChild</font></font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">  </span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">var </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">component = ReactMount.</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">_renderNewRootComponent</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">(   </font><font style="font-family: Menlo; font-size: 12px; color: rgb(169, 183, 198); background-color: rgb(43, 43, 43);">&lt;———— 4</font><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6"><br/>    nextWrappedElement</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">,<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">    </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">container</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">,<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">    </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">shouldReuseMarkup</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">,<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">    </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">nextContext</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">,<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">    </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">callback<br/>  ).</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(152, 118, 170);">_renderedComponent</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">.</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(255, 198, 109);">getPublicInstance</span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">()</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">  </span><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;">return </span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">component</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">;<br/></span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6">}</font><span style="font-family: Menlo; font-size: 9pt; color: rgb(204, 120, 50);">,<br/></span><font style="font-family: Menlo; font-size: 9pt;" color="#a9b7c6"
/></pre><br/></div><div>下面分别展开研究四个函数：</div><div><div><ol start="1"><li>shouldUpdateReactComponent.js ( src/renderers/shared/shared/shouldUpdateReactComponent.js ）</li></ol>这里只做了简单的类型比较，如果父节点的类型不同，则即使子节点相同也不做递归比较，官方文档参见<a href="https://facebook.github.io/react/docs/reconciliation.html#elements-of-different-types">这里</a>。<br/></div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#cc7832;font-weight:bold;">function </span><span style="color:#ffc66d;">shouldUpdateReactComponent</span>(prevElement<span style="color:#cc7832;">, </span>nextElement) {<br/>  <span style="color:#cc7832;font-weight:bold;">var </span>prevEmpty = prevElement === <span style="color:#cc7832;font-weight:bold;">null </span>|| prevElement === <span style="color:#cc7832;font-weight:bold;">false</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>nextEmpty = nextElement === <span style="color:#cc7832;font-weight:bold;">null </span>|| nextElement === <span style="color:#cc7832;font-weight:bold;">false</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(prevEmpty || nextEmpty) {<br/>    <span style="color:#cc7832;font-weight:bold;">return </span>prevEmpty === nextEmpty<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/><br/>  <span style="color:#cc7832;font-weight:bold;">var </span>prevType = <span style="color:#cc7832;font-weight:bold;">typeof </span>prevElement<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>nextType = <span style="color:#cc7832;font-weight:bold;">typeof </span>nextElement<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(prevType === <span style="color:#6a8759;">'string' </span>|| prevType === <span style="color:#6a8759;">'number'</span>) {<br/>    <span style="color:#cc7832;font-weight:bold;">return </span>(nextType === <span style="color:#6a8759;">'string' </span>|| nextType === <span style="color:#6a8759;">'number'</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>} <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>    <span style="color:#cc7832;font-weight:bold;">return </span>(<br/>      nextType === <span style="color:#6a8759;">'object' </span>&amp;&amp;<br/>      prevElement.<span style="color:#9876aa;">type </span>=== nextElement.<span style="color:#9876aa;">type </span>&amp;&amp;<br/>      prevElement.<span style="color:#9876aa;">key </span>=== nextElement.<span style="color:#9876aa;">key<br/></span><span style="color:#9876aa;">    </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/>}<br/>
</pre></div></div><div><font style="font-size: 14px;">  </font></div><div><font style="font-size: 14px;">  2. <span style="font-style: normal; font-variant-caps: normal; font-weight: normal; font-family: Helvetica; color: rgb(69, 69, 69);">ReactMount._updateRootComponent（  src/renderers/dom/stack/client/ReactMount.js ）</span><span style="font-style: normal; font-variant-caps: normal; font-weight: normal; font-family: Helvetica; color: rgb(228, 175, 9);"><br/>
</span></font></div><div>最主要的两句：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;">ReactUpdateQueue.<span style="color:#ffc66d;">enqueueElementInternal</span>(prevComponent<span style="color:#cc7832;">, </span>nextElement<span style="color:#cc7832;">, </span>nextContext)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;font-weight:bold;">if </span>(callback) {<br/>  ReactUpdateQueue.<span style="color:#ffc66d;">enqueueCallbackInternal</span>(prevComponent<span style="color:#cc7832;">, </span>callback)<span style="color:#cc7832;">;<br/></span>}
</pre>这里调用了src/renderers/shared/stack/reconciler/ReactUpdateQueue.js 的两个函数，分别给ReactComponent实例添加属性，要渲染的ReactElemnt、初始化上下文和在渲染完成后执行的回掉函数队列，然后调用ReactUpdates.js (src/renderers/shared/stack/reconciler/ReactUpdates.js)的enqueueUpadate加入到更新队列中（更新策略下文将详细讲解）。</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#ffc66d;">enqueueElementInternal</span>: <span style="color:#cc7832;font-weight:bold;">function</span>(internalInstance<span style="color:#cc7832;">, </span>nextElement<span style="color:#cc7832;">, </span>nextContext) {<br/>  internalInstance.<span style="color:#9876aa;">_pendingElement </span>= nextElement<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#808080;">// </span><span style="color:#a8c023;font-style:italic;">TODO: introduce _pendingContext instead of setting it directly.<br/></span><span style="color:#a8c023;font-style:italic;">  </span>internalInstance.<span style="color:#9876aa;">_context </span>= nextContext<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#ffc66d;">enqueueUpdate</span>(internalInstance)<span style="color:#cc7832;">;<br/></span>}<span style="color:#cc7832;">,</span>
</pre></div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#ffc66d;">enqueueCallbackInternal</span>: <span style="color:#cc7832;font-weight:bold;">function</span>(internalInstance<span style="color:#cc7832;">, </span>callback) {<br/>  <span style="color:#cc7832;font-weight:bold;">if </span>(internalInstance.<span style="color:#9876aa;">_pendingCallbacks</span>) {<br/>    internalInstance.<span style="color:#9876aa;">_pendingCallbacks</span>.<span style="color:#ffc66d;">push</span>(callback)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>} <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>    internalInstance.<span style="color:#9876aa;">_pendingCallbacks </span>= [callback]<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/>  <span style="color:#ffc66d;">enqueueUpdate</span>(internalInstance)<span style="color:#cc7832;">;<br/></span>}<span style="color:#cc7832;">,</span>
</pre><br/></div><div> <font style="font-size: 14px;"> 3.</font><span style="font-style: normal; font-variant-caps: normal; font-weight: normal; font-family: Helvetica; color: rgb(69, 69, 69);"><font style="font-size: 14px;">ReactMount.unmountComponentAtNode</font></span></div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Unmounts and destroys the React component rendered in the `container`.<br/></span><span style="color:#629755;font-style:italic;"> * See <a href="https://facebook.github.io/react/docs/react-dom.html#unmountcomponentatnode">https://facebook.github.io/react/docs/react-dom.html#unmountcomponentatnode</a><br/></span><span style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{DOMElement} container DOM element containing a React component.<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@return </span><span style="color:#629755;font-style:italic;">{boolean} True if a component was found in and unmounted from<br/></span><span style="color:#629755;font-style:italic;"> *                   `container`<br/></span><span style="color:#629755;font-style:italic;"> */<br/></span><span style="color:#ffc66d;">unmountComponentAtNode</span>: <span style="color:#cc7832;font-weight:bold;">function</span>(container) {<br/><br/>  <span style="color:#cc7832;font-weight:bold;">var </span>prevComponent = <span style="color:#ffc66d;">getTopLevelWrapperInContainer</span>(container)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(!prevComponent) {<br/>    <span style="color:#cc7832;font-weight:bold;">return false</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/>  <span style="color:#cc7832;font-weight:bold;">delete </span>instancesByReactRootID[prevComponent.<span style="color:#9876aa;">_instance</span>.rootID]<span style="color:#cc7832;">;//devtools会用到的映射，这里可以先忽略<br/></span><span style="color:#cc7832;">  </span>ReactUpdates.<span style="color:#ffc66d;">batchedUpdates</span>(<br/>    <span style="color:#ffc66d;">unmountComponentFromNode</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>prevComponent<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>container<br/>  )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">return true</span><span style="color:#cc7832;">;<br/></span>}<span style="color:#cc7832;">,</span>
</pre>注意这里也调用ReactUpdates.js (src/renderers/shared/stack/reconciler/ReactUpdates.js)类的函数batchedUpadates更新组件（更新策略下文将详细讲解），传入三个参数，第一个参数作为更新策略执行过程中调用的函数，后两个作为参数，这里要执行的函数是：</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#cc7832;font-weight:bold;">function </span><span style="color:#ffc66d;">unmountComponentFromNode</span>(instance<span style="color:#cc7832;">, </span>container) {<br/>  //这个函数主要作用是：1.去掉组件中的ref引用，调用组件的unmountComponent函数，这里主要有三类组件文本组件、html标签对应的组件和自定义组件，每种对应的unmountComponent实现方式不同，主要做些清理React内部用到的缓存，组件上绑定的事件之类的工作，具体参见下文。<br/>  ReactReconciler.<span style="color:#ffc66d;">unmountComponent</span>(<br/>    instance<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">false </span><span style="color:#808080;">/* safely */</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">false </span><span style="color:#808080;">/* skipLifecycle */<br/></span><span style="color:#808080;">  </span>)<span style="color:#cc7832;">;<br/></span><br/>  <span style="color:#cc7832;font-weight:bold;">if </span>(container.nodeType === DOC_NODE_TYPE) {<br/>    container = container.documentElement<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/><br/>  <span style="color:#808080;">//可以看到这里循环移除了container节点中的全部dom元素，有很多方法可以实现，这里有个有趣的效率对比试验： <a href="http://jsperf.com/emptying-a-node">http://jsperf.com/emptying-a-node</a><br/></span><span style="color:#808080;">  </span><span style="color:#cc7832;font-weight:bold;">while </span>(container.lastChild) {<br/>    container.removeChild(container.lastChild)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/><span style="background-color:#344134;">}</span>
</pre><br/></div><div><ol start="4"><li><span style="font-style: normal; font-variant-caps: normal; font-weight: normal; font-family: Helvetica; color: rgb(69, 69, 69);"><font style="font-size: 14px;">ReactMount._renderNewRootComponent</font></span></li></ol><div><font face="Helvetica" color="#454545">先ReactElement初始<font style="font-size: 14px;">化ReactComponent实例（1），这里可能是自定义组件</font><span style="font-style: normal; font-variant-caps: normal; font-weight: normal; font-family: Helvetica; color: rgb(69, 69, 69);"><font style="font-size: 14px;">ReactCompositeComponent，文本元素对应的ReactDOMTextComponent和浏览器基本元素对应的ReactDOMComponent。然后调用更新策略将组件渲染到container中，以及做一些比如ref绑定等初始化工作（2）。</font><br/>
</span></font></div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#ffc66d;">_renderNewRootComponent</span>: <span style="color:#cc7832;font-weight:bold;">function</span>(<br/>  nextElement<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>container<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>shouldReuseMarkup<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>context<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>callback<br/>) {<br/> //<span style="color: rgb(98, 151, 85); font-style: italic; font-size: 9pt;">Listens to window scroll and resize events. We cache scroll values so that </span><span style="color: rgb(98, 151, 85); font-style: italic; font-size: 9pt;">application code can access them without triggering reflows.这里先不做分析</span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span>ReactBrowserEventEmitter.<span style="color:#ffc66d;">ensureScrollValueMonitoring</span>()<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>componentInstance = instantiateReactComponent(nextElement<span style="color:#cc7832;">, </span><span style="color:#cc7832;font-weight:bold;">false</span>)<span style="color:#cc7832;">; &lt;——— 1<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(callback) {<br/>    componentInstance.<span style="color:#9876aa;">_pendingCallbacks </span>= [<span style="color:#cc7832;font-weight:bold;">function</span>() { //初始化render完成后调用的回掉函数队列<br/>      callback.<span style="color:#ffc66d;">call</span>(componentInstance.<span style="color:#9876aa;">_renderedComponent</span>.<span style="color:#ffc66d;">getPublicInstance</span>())<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}]<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/><br/>  <span style="color:#808080;">// The initial render is synchronous but any updates that happen during<br/></span><span style="color:#808080;">  // rendering, in componentWillMount or componentDidMount, will be batched<br/></span><span style="color:#808080;">  // according to the current batching strategy.<br/></span><span style="color:#808080;"><br/></span><span style="color:#808080;">  </span>ReactUpdates.<span style="color:#ffc66d;">batchedUpdates</span>(  &lt;———— 2<br/>    <span style="color:#ffc66d;">batchedMountComponentIntoNode</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>componentInstance<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>container<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>shouldReuseMarkup<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>context<br/>  )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>wrapperID = componentInstance.<span style="color:#9876aa;">_instance</span>.rootID<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>instancesByReactRootID[wrapperID] = componentInstance<span style="color:#cc7832;">; <font style="font-family: Menlo; font-size: 12px; background-color: rgb(43, 43, 43); color: rgb(204, 120, 50);">//devtools会用到的映射，先忽略</font><br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">return </span>componentInstance<span style="color:#cc7832;">;<br/></span>}<span style="color:#cc7832;">,</span>
</pre><br/></div></div><div>下面分别展开讲解。</div><div><div><ol start="1"><li><font style="font-size: 14px;"> </font><font><span style="font-style: normal; font-variant-caps: normal; font-weight: normal; font-family: Helvetica; color: rgb(69, 69, 69);"><font><font style="font-size: 14px;">instantiateReactComponent（src/<font style="color: rgb(69, 69, 69); font-family: Helvetica;">renderers/shared/stack/reconciler/instantiateReactComponent.js</font>） 初始化组件实例，这里用到了工厂模式，根据传入的参数‘生产’对应的React Component实例。<span style="color: rgb(51, 51, 51); font-family: -apple-system, 'PingFang SC', 'Hiragino Sans GB', Arial, 'Microsoft YaHei', 'Helvetica Neue', sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); float: none;">分别实例化</span><code style="box-sizing: border-box; outline: none; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 0.2em 0.4em; word-break: break-word; color: rgb(78, 89, 128); background-color: rgb(248, 248, 248); border-top-left-radius: 2px; border-top-right-radius: 2px; border-bottom-right-radius: 2px; border-bottom-left-radius: 2px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">ReactDOMTextComponent</code><span style="color: rgb(51, 51, 51); font-family: -apple-system, 'PingFang SC', 'Hiragino Sans GB', Arial, 'Microsoft YaHei', 'Helvetica Neue', sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none;">, </span><code style="box-sizing: border-box; outline: none; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 0.2em 0.4em; word-break: break-word; color: rgb(78, 89, 128); background-color: rgb(248, 248, 248); border-top-left-radius: 2px; border-top-right-radius: 2px; border-bottom-right-radius: 2px; border-bottom-left-radius: 2px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">ReactDOMComponent</code><span style="color: rgb(51, 51, 51); font-family: -apple-system, 'PingFang SC', 'Hiragino Sans GB', Arial, 'Microsoft YaHei', 'Helvetica Neue', sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); float: none;">, </span><code style="box-sizing: border-box; outline: none; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 0.2em 0.4em; word-break: break-word; color: rgb(78, 89, 128); background-color: rgb(248, 248, 248); border-top-left-radius: 2px; border-top-right-radius: 2px; border-bottom-right-radius: 2px; border-bottom-left-radius: 2px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">ReactCompositeComponent</code><span style="color: rgb(51, 51, 51); font-family: -apple-system, 'PingFang SC', 'Hiragino Sans GB', Arial, 'Microsoft YaHei', 'Helvetica Neue', sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none;">类。这些类用来管理</span><code style="box-sizing: border-box; outline: none; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 0.2em 0.4em; word-break: break-word; color: rgb(78, 89, 128); background-color: rgb(248, 248, 248); border-top-left-radius: 2px; border-top-right-radius: 2px; border-bottom-right-radius: 2px; border-bottom-left-radius: 2px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">ReactElement</code><span style="color: rgb(51, 51, 51); font-family: -apple-system, 'PingFang SC', 'Hiragino Sans GB', Arial, 'Microsoft YaHei', 'Helvetica Neue', sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none;">,负责将不同的</span><code style="box-sizing: border-box; outline: none; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 0.2em 0.4em; word-break: break-word; color: rgb(78, 89, 128); background-color: rgb(248, 248, 248); border-top-left-radius: 2px; border-top-right-radius: 2px; border-bottom-right-radius: 2px; border-bottom-left-radius: 2px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">ReactElement</code><span style="color: rgb(51, 51, 51); font-family: -apple-system, 'PingFang SC', 'Hiragino Sans GB', Arial, 'Microsoft YaHei', 'Helvetica Neue', sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; float: none;">转化成DOM(通过mountComponent方法),负责更新DOM(通过receiveComponent方法，updateComponent方法，下面详细介绍)等。</span></font></font></span></font></li></ol><div style="text-align: center; "><img src="/images/2017-01-20/%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%9B%BE%20(1).png" height="251" width="554"/><br/></div><div><font face="Helvetica" color="#454545"/></div></div></div><div><font face="Helvetica" color="#454545"><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Given a ReactNode, create an instance that will actually be mounted.<br/></span><span style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactNode} node<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{boolean} shouldHaveDebugID<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@return </span><span style="color:#629755;font-style:italic;">{object} A new instance of the element's constructor.<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@protected<br/></span><span style="color:#629755;font-weight:bold;font-style:italic;" /><span style="color:#629755;font-style:italic;">*/<br/></span><span style="color:#cc7832;font-weight:bold;">function </span><span style="color:#ffc66d;">instantiateReactComponent</span>(node<span style="color:#cc7832;">, </span>shouldHaveDebugID) {<br/>  <span style="color:#cc7832;font-weight:bold;">var </span>instance<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(node === <span style="color:#cc7832;font-weight:bold;">null </span>|| node === <span style="color:#cc7832;font-weight:bold;">false</span>) {<br/>    instance = ReactEmptyComponent.<span style="color:#ffc66d;">create</span>(<span style="color:#ffc66d;">instantiateReactComponent</span>)<span style="color:#cc7832;">;//这里生成一个空的component对象</span><span style="font-size: 9pt;">ReactDOMEmptyComponent，渲染一行注释，可以忽略</span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span>} <span style="color:#cc7832;font-weight:bold;">else if </span>(<span style="color:#cc7832;font-weight:bold;">typeof </span>node === <span style="color:#6a8759;">'object'</span>) {<br/>    <span style="color:#cc7832;font-weight:bold;">var </span>element = node<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>type = element.<span style="color:#9876aa;">type</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;"><br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(<span style="color:#cc7832;font-weight:bold;">typeof </span>element.<span style="color:#9876aa;">type </span>=== <span style="color:#6a8759;">'string'</span>) { //如果类型是浏览器标签比如“div”、“span”之类 创建<font style="font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; background-color: rgb(248, 248, 248); color: rgb(78, 89, 128);">ReactDOMComponent 对象</font><br/>      instance = ReactHostComponent.<span style="color:#ffc66d;">createInternalComponent</span>(element)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>} <span style="color:#cc7832;font-weight:bold;">else if </span>(<span style="color:#ffc66d;">isInternalComponentType</span>(element.<span style="color:#9876aa;">type</span>)) {//这个判断是否是内部组件的方式没有遇到过（待研究补充）<br/>      <span style="color:#808080;">// This is temporarily available for custom components that are not string<br/></span><span style="color:#808080;">      // representations. I.e. ART. Once those are updated to use the string<br/></span><span style="color:#808080;">      // representation, we can drop this code path.<br/></span><span style="color:#808080;">      </span>instance = <span style="color:#cc7832;font-weight:bold;">new </span>element.<span style="color:#9876aa;">type</span>(element)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">      </span><span style="color:#808080;">// We renamed this. Allow the old name for compat. :(<br/></span><span style="color:#808080;">      </span><span style="color:#cc7832;font-weight:bold;">if </span>(!instance.<span style="color:#9876aa;">getHostNode</span>) {<br/>        instance.<span style="color:#9876aa;">getHostNode </span>= instance.<span style="color:#ffc66d;">getNativeNode</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>}<br/>    } <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>      instance = <span style="color:#cc7832;font-weight:bold;">new </span><span style="color:#ffc66d;">ReactCompositeComponentWrapper</span>(element)<span style="color:#cc7832;">; //创建自定义组件<font style="font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; background-color: rgb(248, 248, 248); color: rgb(78, 89, 128);">ReactCompositeComponent对象</font><br/></span><span style="color:#cc7832;">    </span>}<br/>  } <span style="color:#cc7832;font-weight:bold;">else if </span>(<span style="color:#cc7832;font-weight:bold;">typeof </span>node === <span style="color:#6a8759;">'string' </span>|| <span style="color:#cc7832;font-weight:bold;">typeof </span>node === <span style="color:#6a8759;">'number'</span>) {<span style="color:#cc7832;">//创建文本节点<font style="font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; background-color: rgb(248, 248, 248); color: rgb(78, 89, 128);">ReactDOMTextComponent 对象</font></span><br/>    instance = ReactHostComponent.<span style="color:#ffc66d;">createInstanceForText</span>(node)<span style="color:#cc7832;">; <br/></span><span style="color:#cc7832;">  </span>} <br/><br/>  <span style="color:#808080;">// These two fields are used by the DOM and ART diffing algorithms<br/></span><span style="color:#808080;">  // respectively. Instead of using expandos on components, we should be<br/></span><span style="color:#808080;">  // storing the state needed by the diffing algorithms elsewhere.<br/></span><span style="color:#808080;">  </span>instance.<span style="color:#9876aa;">_mountIndex </span>= <span style="color:#6897bb;">0</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>instance.<span style="color:#9876aa;">_mountImage </span>= <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><br/>  <span style="color:#cc7832;font-weight:bold;">return </span>instance<span style="color:#cc7832;">;<br/></span>}<br/></pre></font></div><div><font face="Helvetica" color="#454545"><br/></font></div><div><font face="Helvetica" color="#454545">下面分别展开介绍三种组件的渲染、更新、卸载策略。</font></div><div><br/></div><div><font face="Helvetica" color="#454545">1.1）<font style="font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; background-color: rgb(248, 248, 248); font-size: 12px; color: rgb(78, 89, 128);">ReactDOMTextComponent（src/<font style="font-size: 12px; color: rgb(78, 89, 128); font-family: Menlo;">renderers/dom/stack/client/ReactDOMTextComponent.js）</font></font></font></div><div><font face="Helvetica" color="#454545"><font style="font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; background-color: rgb(248, 248, 248); font-size: 12px; color: rgb(78, 89, 128);"><font style="font-size: 12px; color: rgb(78, 89, 128); font-family: Menlo;"/></font></font></div><div>重点看下三个函数：</div><div><br/></div><div>    1) mountComponent 在render的时候调用，返回渲染内容，针对文本节点返回：</div><div>        &lt;!-- react-text:domId —&gt;这是文本内容&lt;!-- /react-text —&gt;</div><div><br/></div><div><div>  2）receiveComponent 在setState触发更新时调用这个函数，如果文本不同，只替换了注释中的内容。</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#ffc66d;">receiveComponent</span>: <span style="color:#cc7832;font-weight:bold;">function</span>(nextText<span style="color:#cc7832;">, </span>transaction) {<br/>  <span style="color:#cc7832;font-weight:bold;">if </span>(nextText !== <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_currentElement</span>) {<br/>    <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_currentElement </span>= nextText<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>nextStringText = <span style="color:#6a8759;">'' </span>+ nextText<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(nextStringText !== <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_stringText</span>) {<span style="color:#808080;"><br/></span><span style="color:#808080;">      </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_stringText </span>= nextStringText<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span><span style="color:#cc7832;font-weight:bold;">var </span>commentNodes = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">getHostNode</span>()<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>DOMChildrenOperations.<span style="color:#ffc66d;">replaceDelimitedText</span>(<br/>        commentNodes[<span style="color:#6897bb;">0</span>]<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>commentNodes[<span style="color:#6897bb;">1</span>]<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>nextStringText<br/>      )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/>  }<br/>}<span style="color:#cc7832;">,</span>
</pre><br/></div><div>3）unmountComponent 去掉对text节点引用，重置一些变量。</div><div><br/></div><div><br/></div><div>1.2）<font style="font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; background-color: rgb(248, 248, 248); color: rgb(78, 89, 128);">ReactDOMComponent</font></div><div><br/></div><div>    1）mountComponent 生成组件对应的dom结构</div><div>代码比较长，主要分为四个步骤：</div><div><ol start="1"><li>做一些生成markup前的“准备工作”  ，针对不同类型做一些变量初始化以及让React事件系统捕捉指定事件。</li></ol>           以input标签为例介绍一下：<br/><div><ul><li> ReactDOMInput.mountWrapper(this, props, hostParent);  <br/></li></ul></div><div>           给input组件实例初始化状态，mountWrapper函数里只给实例设置了一个属性用以保存input的初始value和初始checked值。</div><div>           <span style="color:#cc7832;font-weight:bold;">var </span>defaultValue = props.<span style="color:#9876aa;">defaultValue</span><span style="color:#cc7832;">;<br/></span><span>    <span>       </span></span>inst.<span style="color:#9876aa;">_wrapperState </span>= {</div><div><span style="color:#9876aa;">             initialChecked</span>: props.<span style="color:#9876aa;">checked </span>!= <span style="color:#cc7832;font-weight:bold;">null </span>? props.<span style="color:#9876aa;">checked </span>: props.<span style="color:#9876aa;">defaultChecked</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  <span>           </span></span><span style="color:#9876aa;">initialValue</span>: props.<span style="color:#9876aa;">value </span>!= <span style="color:#cc7832;font-weight:bold;">null </span>? props.<span style="color:#9876aa;">value </span>: defaultValue<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;"><span>    <span>  </span></span>       </span><span style="color:#9876aa;">listeners</span>: <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">,<br/></span>           }<span style="color:#cc7832;">;</span></div><div><ul><li> props = ReactDOMInput.getHostProps(this, props); 将更多input元素要用到的属性初始化并赋给事例，如value、type、max、min等等</li><li> transaction.getReactMountReady().enqueue(trackInputValue, this);<br/></li><li> transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this); 添加预定义事件，这里react添加了invalid事件</li><li> ensureListeningTo(this, 'onChange', transaction); 对于受控组件确保监听on change事件</li></ul><div><br/></div><div/></div><ol start="2"><li>设置正确的namespace，根据父容器的namespace类型和当前实例的tag类型设置namespace 变量是html svg还是mathml<br/></li><li><b>创建将渲染在页面的markup（重要！！！讲解参见注释）</b></li></ol><div><ol start="4"><li>做一些“收尾”工作，比如input、texture的内容初始化以及各个元素的autofocus设置<br/></li></ol></div></div><div>       </div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><br/><span style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Generates root tag markup then recurses. This method has side effects and<br/></span><span style="color:#629755;font-style:italic;"> * is not idempotent.<br/></span><span style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@internal<br/></span><span style="color:#629755;font-weight:bold;font-style:italic;" /><span style="color:#629755;font-style:italic;">* </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactReconcileTransaction|ReactServerRenderingTransaction} transaction<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{?ReactDOMComponent} the parent component instance<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{?object} info about the host container<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{object} context<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@return </span><span style="color:#629755;font-style:italic;">{string} The computed markup.<br/></span><span style="color:#629755;font-style:italic;"> */<br/></span>mountComponent: <span style="color:#cc7832;font-weight:bold;">function</span>(<br/>    transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>hostParent<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>hostContainerInfo<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>context<br/>) {<br/>    <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_rootNodeID </span>= globalIdCounter++<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_domID </span>= hostContainerInfo.<span style="color:#9876aa;">_idCounter</span>++<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_hostParent </span>= hostParent<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_hostContainerInfo </span>= hostContainerInfo<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>props = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_currentElement</span>.<span style="color:#9876aa;">props</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">switch </span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_tag</span>) {  &lt;———— <span style="color:#6897bb;">1 </span>做一些生成markup前的“准备工作”<br/>        <span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6a8759;">'audio'</span>:<br/>        <span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6a8759;">'form'</span>:<br/>        <span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6a8759;">'iframe'</span>:<br/>        <span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6a8759;">'img'</span>:<br/>        <span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6a8759;">'link'</span>:<br/>        <span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6a8759;">'object'</span>:<br/>        <span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6a8759;">'source'</span>:<br/>        <span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6a8759;">'video'</span>:<br/>        <span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6a8759;">'details'</span>:<br/>            <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_wrapperState </span>= {<br/>                <span style="color:#9876aa;">listeners</span>: <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>}<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span><span style="color:#808080;">//针对一些特性元素预先绑定一些事件<br/></span><span style="color:#808080;">            </span>transaction.<span style="color:#ffc66d;">getReactMountReady</span>().<span style="color:#ffc66d;">enqueue</span>(<span style="color:#ffc66d;">trapBubbledEventsLocal</span><span style="color:#cc7832;">, </span><span style="color:#cc7832;font-weight:bold;">this</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span><span style="color:#cc7832;font-weight:bold;">break</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6a8759;">'input'</span>:<span style="color:#808080;">//给input组件实例初始化状态<br/></span><span style="color:#808080;">            </span>ReactDOMInput.<span style="color:#ffc66d;">mountWrapper</span>(<span style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">, </span>props<span style="color:#cc7832;">, </span>hostParent)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span>props = ReactDOMInput.<span style="color:#ffc66d;">getHostProps</span>(<span style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">, </span>props)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span>transaction.<span style="color:#ffc66d;">getReactMountReady</span>().<span style="color:#ffc66d;">enqueue</span>(<span style="color:#ffc66d;">trackInputValue</span><span style="color:#cc7832;">, </span><span style="color:#cc7832;font-weight:bold;">this</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span>transaction.<span style="color:#ffc66d;">getReactMountReady</span>().<span style="color:#ffc66d;">enqueue</span>(<span style="color:#ffc66d;">trapBubbledEventsLocal</span><span style="color:#cc7832;">, </span><span style="color:#cc7832;font-weight:bold;">this</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span><span style="color:#808080;">// For controlled components we always need to ensure we're listening<br/></span><span style="color:#808080;">            // to onChange. Even if there is no listener.<br/></span><span style="color:#808080;">            </span><span style="color:#ffc66d;">ensureListeningTo</span>(<span style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">, </span><span style="color:#6a8759;">'onChange'</span><span style="color:#cc7832;">, </span>transaction)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span><span style="color:#cc7832;font-weight:bold;">break</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">       //略去其他……</span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span>}<br/><br/>    <span style="color:#ffc66d;">assertValidProps</span>(<span style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">, </span>props)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;">// We create tags in the namespace of their parent container, except HTML<br/></span><span style="color:#808080;">    // tags get no namespace.<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>namespaceURI<span style="color:#cc7832;">; </span>&lt;————— <span style="color:#6897bb;">2 </span>设置正确的namespace<br/>    <span style="color:#cc7832;font-weight:bold;">var </span>parentTag<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(hostParent != <span style="color:#cc7832;font-weight:bold;">null</span>) {<br/>        namespaceURI = hostParent.<span style="color:#9876aa;">_namespaceURI</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>parentTag = hostParent.<span style="color:#9876aa;">_tag</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>} <span style="color:#cc7832;font-weight:bold;">else if </span>(hostContainerInfo.<span style="color:#9876aa;">_tag</span>) {<br/>        namespaceURI = hostContainerInfo.<span style="color:#9876aa;">_namespaceURI</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>parentTag = hostContainerInfo.<span style="color:#9876aa;">_tag</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/>    <span style="color:#cc7832;font-weight:bold;">if </span>(namespaceURI == <span style="color:#cc7832;font-weight:bold;">null </span>||<br/>        namespaceURI === DOMNamespaces.<span style="color:#9876aa;">svg </span>&amp;&amp; parentTag === <span style="color:#6a8759;">'foreignobject'</span>) {<br/>        namespaceURI = DOMNamespaces.<span style="color:#9876aa;">html</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/>    <span style="color:#cc7832;font-weight:bold;">if </span>(namespaceURI === DOMNamespaces.<span style="color:#9876aa;">html</span>) {<br/>        <span style="color:#cc7832;font-weight:bold;">if </span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_tag </span>=== <span style="color:#6a8759;">'svg'</span>) {<br/>            namespaceURI = DOMNamespaces.<span style="color:#9876aa;">svg</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>} <span style="color:#cc7832;font-weight:bold;">else if </span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_tag </span>=== <span style="color:#6a8759;">'math'</span>) {<br/>            namespaceURI = DOMNamespaces.<span style="color:#9876aa;">mathml</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>}<br/>    }<br/>    <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_namespaceURI </span>= namespaceURI<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>mountImage<span style="color:#cc7832;">; </span>&lt;————— <span style="color:#6897bb;">3 </span>创建将渲染在页面的markup<br/>    <span style="color:#cc7832;font-weight:bold;">var </span>type = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_currentElement</span>.<span style="color:#9876aa;">type</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;">//默认用createElement创建<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(transaction.<span style="color:#9876aa;">useCreateElement</span>) {<br/>        <span style="color:#cc7832;font-weight:bold;">var </span>ownerDocument = hostContainerInfo.<span style="color:#9876aa;">_ownerDocument</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">var </span>el<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">if </span>(namespaceURI === DOMNamespaces.<span style="color:#9876aa;">html</span>) {<br/>            <span style="color:#cc7832;font-weight:bold;">if </span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_tag </span>=== <span style="color:#6a8759;">'script'</span>) {<br/>                <span style="color:#808080;">//如果是script标签，注意这里包在div里再获取<br/></span><span style="color:#808080;">                // Create the script via .innerHTML so its "parser-inserted" flag is<br/></span><span style="color:#808080;">                // set to true and it does not execute<br/></span><span style="color:#808080;">                </span><span style="color:#cc7832;font-weight:bold;">var </span>div = ownerDocument.<span style="color:#ffc66d;">createElement</span>(<span style="color:#6a8759;">'div'</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">                </span>div.<span style="color:#9876aa;">innerHTML </span>= <span style="color:#6a8759;">`&lt;</span>${type}<span style="color:#6a8759;">&gt;&lt;/</span>${type}<span style="color:#6a8759;">&gt;`</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">                </span>el = div.<span style="color:#ffc66d;">removeChild</span>(div.<span style="color:#9876aa;">firstChild</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span>} <span style="color:#cc7832;font-weight:bold;">else if </span>(props.<span style="color:#9876aa;">is</span>) {<br/>                <span style="color:#808080;">//和用户自定义元素相关，参见：https://developer.<a href="http://mozilla.org/en-US/docs/Web/API/Document/createElement">mozilla.org/en-US/docs/Web/API/Document/createElement</a> <br/></span><span style="color:#808080;">                //https://www.<a href="http://w3.org/TR/custom-elements/#customized-built-in-element">w3.org/TR/custom-elements/#customized-built-in-element</a> 同时也是为了解决firefox下createElement的bug<br/></span><span style="color:#808080;">                </span>el = ownerDocument.<span style="color:#ffc66d;">createElement</span>(type<span style="color:#cc7832;">, </span>props.<span style="color:#9876aa;">is</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span>} <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>                <span style="color:#808080;">// Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.<br/></span><span style="color:#808080;">                // See discussion in <a href="https://github.com/facebook/react/pull/6896">https://github.com/facebook/react/pull/6896</a><br/></span><span style="color:#808080;">                // and discussion in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1276240">https://bugzilla.mozilla.org/show_bug.cgi?id=1276240</a><br/></span><span style="color:#808080;">                </span>el = ownerDocument.<span style="color:#ffc66d;">createElement</span>(type)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span>}<br/>        } <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>            el = ownerDocument.<span style="color:#ffc66d;">createElementNS</span>(<br/>                namespaceURI<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">                </span>type<br/>            )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>}<br/>        <span style="color:#808080;">//如果tag名包含’－’或指定“is”属性认为是用户自定义标签<br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">var </span>isCustomComponentTag = <span style="color:#ffc66d;">isCustomComponent</span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_tag</span><span style="color:#cc7832;">, </span>props)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#808080;">//分别在react实例添加属性指向刚创建的节点，同时给节点添加属性指向当前实例<br/></span><span style="color:#808080;">        </span>ReactDOMComponentTree.<span style="color:#ffc66d;">precacheNode</span>(<span style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">, </span>el)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_flags </span>|= Flags.<span style="color:#9876aa;">hasCachedChildNodes</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#808080;">//如果是最外层标签，不是递归创建的子节点，则设置为React根元素，比如ReactDom.render(‘&lt;div&gt;&lt;input/&gt;&lt;/div&gt;’,node) 在创建到div层的时候设置为根元素，然后递归渲染子元素（input）的时候hostParent不为空了。<br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">if </span>(!<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_hostParent</span>) {<br/>            DOMPropertyOperations.<span style="color:#ffc66d;">setAttributeForRoot</span>(el)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>}<br/>        <span style="color:#808080;">//根据新旧props的差异更新对应dom元素上的属性，首次渲染没有旧props<br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_updateDOMProperties</span>(<span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">, </span>props<span style="color:#cc7832;">, </span>transaction<span style="color:#cc7832;">, </span>isCustomComponentTag)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#808080;">//初始化DOMLazyTree结构，根据不同浏览器选择不同的渲染策略，参见（src/renderers/dom/stack/client/DOMLazyTree.js）<br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">var </span>lazyTree = DOMLazyTree(el)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#808080;">//如果有子节点，则遍历子节点递归调用ReactReconciler.mountComponent（这个函数主要还是调用子节点实例对应的mountComponent）生成子节点的markup（可以简单理解为子节点dom树），保存到lazyTree中，<br/></span><span style="color:#808080;">        //根据不同浏览器渲染dom的效率选择将子元素缓存在DOMLazyTree的队列中延迟渲染还是直接拼成一个完整的dom树返回<br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_createInitialChildren</span>(transaction<span style="color:#cc7832;">, </span>props<span style="color:#cc7832;">, </span>context<span style="color:#cc7832;">, </span>lazyTree)<span style="color:#cc7832;">;    &lt;============<br/></span><span style="color:#cc7832;">        </span>mountImage = lazyTree<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>} <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>        <span style="color:#808080;">//判断是否是合法的tag名（用正则）<br/></span><span style="color:#808080;">        </span><span style="color:#ffc66d;">validateDangerousTag</span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_tag</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#808080;">//用字符串拼接的方式创建起始标签，并添加事件监听、属性和样式内容<br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">var </span>tagOpen = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_createOpenTagMarkupAndPutListeners</span>(transaction<span style="color:#cc7832;">, </span>props)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#808080;">//如果有子节点，则遍历子节点递归生成每一个子节点的ReactComponent实例，然后调用每个实例的ReactReconciler.mountComponent生成子节点的dom树<br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">var </span>tagContent = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_createContentMarkup</span>(transaction<span style="color:#cc7832;">, </span>props<span style="color:#cc7832;">, </span>context)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#808080;">//闭合标签<br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">if </span>(!tagContent &amp;&amp; omittedCloseTags[<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_tag</span>]) {<br/>            mountImage = tagOpen + <span style="color:#6a8759;">'/&gt;'</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>} <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>            mountImage = tagOpen + <span style="color:#6a8759;">'&gt;' </span>+ tagContent + <span style="color:#6a8759;">'&lt;/' </span>+ type + <span style="color:#6a8759;">'&gt;'</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>}<br/>    }<br/><br/>    <span style="color:#cc7832;font-weight:bold;">switch </span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_tag</span>) { &lt;—————<span style="color:#6897bb;">4 </span>给事务添加组件渲染完毕后做的事情<br/>        <span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6a8759;">'input'</span>:<br/>            transaction.<span style="color:#ffc66d;">getReactMountReady</span>().<span style="color:#ffc66d;">enqueue</span>(<br/>                <span style="color:#ffc66d;">inputPostMount</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">                </span><span style="color:#cc7832;font-weight:bold;">this<br/></span><span style="color:#cc7832;font-weight:bold;">            </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span><span style="color:#cc7832;font-weight:bold;">if </span>(props.<span style="color:#9876aa;">autoFocus</span>) {<br/>                transaction.<span style="color:#ffc66d;">getReactMountReady</span>().<span style="color:#ffc66d;">enqueue</span>(<br/>                    AutoFocusUtils.<span style="color:#ffc66d;">focusDOMComponent</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">                    </span><span style="color:#cc7832;font-weight:bold;">this<br/></span><span style="color:#cc7832;font-weight:bold;">                </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span>}<br/>            <span style="color:#cc7832;font-weight:bold;">break</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">       //略去其他……  </span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span>}<br/><br/>    <span style="color:#cc7832;font-weight:bold;">return </span>mountImage<span style="color:#cc7832;">;<br/></span>}
</pre>这里额外讲一下 <b>this._createInitialChildren(transaction, props, context, lazyTree)</b>生成子元素dom树的函数，如果props.children是数组，调用以下函数。</div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#ffc66d;">mountChildren</span>: <span style="color:#cc7832;font-weight:bold;">function</span>(nestedChildren<span style="color:#cc7832;">, </span>transaction<span style="color:#cc7832;">, </span>context) {<br/>  <span style="color:#cc7832;font-weight:bold;">var </span>children = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_reconcilerInstantiateChildren</span>(<span style="color:#808080;">//深度遍历子节点获得所有子节点，同时调用</span><span style="font-size: 9pt; background-color: rgb(52, 65, 52);">instantiateReactComponent生成子节点对应的</span><span style="font-size: 9pt; color: rgb(128, 128, 128);">ReactComponent组</span><span style="color:#808080;"><br/></span><span style="color:#808080;">    </span>nestedChildren<span style="color:#cc7832;">, </span>transaction<span style="color:#cc7832;">, </span>context<br/>  )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_renderedChildren </span>= children<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>mountImages = []<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>index = <span style="color:#6897bb;">0</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">for </span>(<span style="color:#cc7832;font-weight:bold;">var </span>name <span style="color:#cc7832;font-weight:bold;">in </span>children) {<br/>    <span style="color:#cc7832;font-weight:bold;">if </span>(children.<span style="color:#9876aa;">hasOwnProperty</span>(name)) {<br/>      <span style="color:#cc7832;font-weight:bold;">var </span>child = children[name]<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span><span style="color:#cc7832;font-weight:bold;">var </span>selfDebugID = <span style="color:#6897bb;">0</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">     </span><br/>      <span style="color:#cc7832;font-weight:bold;">var </span>mountImage = ReactReconciler.<span style="color:#ffc66d;">mountComponent</span>(//调用每个子节点的ReactComponent实例的mountComponent递归渲染所有子节点<br/>        child<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_hostContainerInfo</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>context<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>selfDebugID<br/>      )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>child.<span style="color:#9876aa;">_mountIndex </span>= index++<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>mountImages.<span style="color:#ffc66d;">push</span>(mountImage)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/>  }<br/>  <span style="color:#cc7832;font-weight:bold;">return </span>mountImages<span style="color:#cc7832;">;<br/></span>}<span style="color:#cc7832;">,<br/></span>
</pre> </div><div><div/><div>再顺便提一下，源码中用到了DOMLazyTree，并根据不同浏览器对dom片段生成的速度做了优化。</div><div><pre style="background-color: rgb(43, 43, 43); font-family: Menlo; font-size: 9pt;"><pre style="background-color: rgb(43, 43, 43); font-family: Menlo; font-size: 9pt;"><span style="color: rgb(98, 151, 85); font-style: italic;">/**<br/></span><span style="color: rgb(98, 151, 85); font-style: italic;"> * In IE (8-11) and Edge, appending nodes with no children is dramatically<br/></span><span style="color: rgb(98, 151, 85); font-style: italic;"> * faster than appending a full subtree, so we essentially queue up the<br/></span><span style="color: rgb(98, 151, 85); font-style: italic;"> * .appendChild calls here and apply them so each node is added to its parent<br/></span><span style="color: rgb(98, 151, 85); font-style: italic;"> * before any children are added.<br/></span><span style="color: rgb(98, 151, 85); font-style: italic;"> *<br/></span><span style="color: rgb(98, 151, 85); font-style: italic;"> * In other browsers, doing so is slower or neutral compared to the other order<br/></span><span style="color: rgb(98, 151, 85); font-style: italic;"> * (in Firefox, twice as slow) so we only do this inversion in IE.<br/></span><span style="color: rgb(98, 151, 85); font-style: italic;"> *<br/></span><span style="color: rgb(98, 151, 85); font-style: italic;"> * See <a href="https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode">https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode</a>.<br/></span><span style="color: rgb(98, 151, 85); font-style: italic;"> */<br/></span><span style="color: rgb(204, 120, 50); font-weight: bold;">var </span><font color="#a9b7c6">enableLazy = (<br/>  </font><span style="color: rgb(204, 120, 50); font-weight: bold;">typeof </span><span style="color: rgb(152, 118, 170);">document </span><font color="#a9b7c6">!== </font><span style="color: rgb(106, 135, 89);">'undefined' </span><font color="#a9b7c6">&amp;&amp;<br/>  </font><span style="color: rgb(204, 120, 50); font-weight: bold;">typeof </span><span style="color: rgb(152, 118, 170);">document</span><font color="#a9b7c6">.</font><span style="color: rgb(152, 118, 170);">documentMode </span><font color="#a9b7c6">=== </font><span style="color: rgb(106, 135, 89);">'number'<br/></span><span style="color: rgb(106, 135, 89);">  </span><font color="#a9b7c6">||<br/>  </font><span style="color: rgb(204, 120, 50); font-weight: bold;">typeof </span><span style="color: rgb(152, 118, 170);">navigator </span><font color="#a9b7c6">!== </font><span style="color: rgb(106, 135, 89);">'undefined' </span><font color="#a9b7c6">&amp;&amp;<br/>  </font><span style="color: rgb(204, 120, 50); font-weight: bold;">typeof </span><span style="color: rgb(152, 118, 170);">navigator</span><font color="#a9b7c6">.</font><span style="color: rgb(152, 118, 170);">userAgent </span><font color="#a9b7c6">=== </font><span style="color: rgb(106, 135, 89);">'string' </span><font color="#a9b7c6">&amp;&amp;<br/>  </font><span style="color: rgb(106, 135, 89);">/\bEdge\/\d/</span><font color="#a9b7c6">.</font><span style="color: rgb(255, 198, 109);">test</span><font color="#a9b7c6">(</font><span style="color: rgb(152, 118, 170);">navigator</span><font color="#a9b7c6">.</font><span style="color: rgb(152, 118, 170);">userAgent</span><font color="#a9b7c6">)<br/>)</font>;</pre><pre style="background-color: rgb(43, 43, 43); font-family: Menlo; font-size: 9pt;"><span style="font-size: 9pt; color: rgb(204, 120, 50); font-weight: bold;"> function </span><span style="font-size: 9pt; color: rgb(255, 198, 109);">queueChild</span><font style="font-size: 9pt;" color="#a9b7c6">(parentTree</font><span style="font-size: 9pt; color: rgb(204, 120, 50);">, </span><font style="font-size: 9pt;" color="#a9b7c6">childTree) {</font><br/></pre><pre style="background-color: rgb(43, 43, 43); font-family: Menlo; font-size: 9pt;"><pre style="background-color: rgb(43, 43, 43); font-family: Menlo; font-size: 9pt;"><font color="#a9b7c6">  </font><span style="color: rgb(204, 120, 50); font-weight: bold;">if </span><font color="#a9b7c6">(enableLazy) {<br/>    parentTree.</font><span style="color: rgb(152, 118, 170);">children</span><font color="#a9b7c6">.</font><span style="color: rgb(255, 198, 109);">push</span><font color="#a9b7c6">(childTree)</font><span style="color: rgb(204, 120, 50);">;<br/></span><span style="color: rgb(204, 120, 50);">  </span><font color="#a9b7c6">} </font><span style="color: rgb(204, 120, 50); font-weight: bold;">else </span><font color="#a9b7c6">{<br/>    parentTree.node.</font><span style="color: rgb(152, 118, 170);">appendChild</span><font color="#a9b7c6">(childTree.node)</font><span style="color: rgb(204, 120, 50);">;<br/></span><span style="color: rgb(204, 120, 50);">  </span><font color="#a9b7c6">}<br/></font><span style="color: rgb(169, 183, 198); background-color: rgb(52, 65, 52);">}</span><font color="#a9b7c6"
/></pre><br/></pre></pre></div><div><font face="Helvetica" color="#454545"><font style="font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; background-color: rgb(248, 248, 248); font-size: 12px; color: rgb(78, 89, 128);"/></font></div></div><div><div>然后会在这里判断是把子节点缓存起来还是直接挂到父节点上。缓存起来的节点会在ReactMount的_mountImageIntoNode递归地将子节点逐个挂到父节点上，主要用在<code style="box-sizing: border-box; outline: none; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 0.2em 0.4em; word-break: break-word; color: rgb(78, 89, 128); background-color: rgb(248, 248, 248); border-top-left-radius: 2px; border-top-right-radius: 2px; border-bottom-right-radius: 2px; border-bottom-left-radius: 2px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">ReactDOMComponent</code><span style="color: rgb(51, 51, 51); font-family: -apple-system, 'PingFang SC', 'Hiragino Sans GB', Arial, 'Microsoft YaHei', 'Helvetica Neue', sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); float: none;">, </span><code style="box-sizing: border-box; outline: none; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 0.2em 0.4em; word-break: break-word; color: rgb(78, 89, 128); background-color: rgb(248, 248, 248); border-top-left-radius: 2px; border-top-right-radius: 2px; border-bottom-right-radius: 2px; border-bottom-left-radius: 2px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">ReactCompositeComponent。</code></div><div/><div><br/></div>  </div><div>2）receiveComponent 在setState触发更新时调用这个函</div><div><div/></div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"/></div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Updates a DOM component after it has already been allocated and<br/></span><span style="color:#629755;font-style:italic;"> * attached to the DOM. Reconciles the root DOM node, then recurses.<br/></span><span style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactReconcileTransaction} transaction<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactElement} prevElement<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactElement} nextElement<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@internal<br/></span><span style="color:#629755;font-weight:bold;font-style:italic;" /><span style="color:#629755;font-style:italic;">* </span><span style="color:#629755;font-weight:bold;font-style:italic;">@overridable<br/></span><span style="color:#629755;font-weight:bold;font-style:italic;" /><span style="color:#629755;font-style:italic;">*/<br/></span><span style="color:#ffc66d;">updateComponent</span>: <span style="color:#cc7832;font-weight:bold;">function</span>(transaction<span style="color:#cc7832;">, </span>prevElement<span style="color:#cc7832;">, </span>nextElement<span style="color:#cc7832;">, </span>context) {<br/>  <span style="color:#cc7832;font-weight:bold;">var </span>lastProps = prevElement.props<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>nextProps = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_currentElement</span>.props<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  //获得last 和next props<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">switch </span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_tag</span>) {<br/>    <span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6a8759;">'input'</span>:<br/>      lastProps = ReactDOMInput.<span style="color:#ffc66d;">getHostProps</span>(<span style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">, </span>lastProps)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>nextProps = ReactDOMInput.<span style="color:#ffc66d;">getHostProps</span>(<span style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">, </span>nextProps)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span><span style="color:#cc7832;font-weight:bold;">break</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    //略去其他……</span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">default</span>:<br/>      <span style="color:#cc7832;font-weight:bold;">if </span>(<span style="color:#cc7832;font-weight:bold;">typeof </span>lastProps.<span style="color:#9876aa;">onClick </span>!== <span style="color:#6a8759;">'function' </span>&amp;&amp;<br/>          <span style="color:#cc7832;font-weight:bold;">typeof </span>nextProps.<span style="color:#9876aa;">onClick </span>=== <span style="color:#6a8759;">'function'</span>) {<br/>        transaction.getReactMountReady().<span style="color:#ffc66d;">enqueue</span>(<br/>          <span style="color:#ffc66d;">trapClickOnNonInteractiveElement</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">          </span><span style="color:#cc7832;font-weight:bold;">this<br/></span><span style="color:#cc7832;font-weight:bold;">        </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span>}<br/>      <span style="color:#cc7832;font-weight:bold;">break</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/><br/>  <span style="color:#ffc66d;">assertValidProps</span>(<span style="color:#cc7832;font-weight:bold;">this</span><span style="color:#cc7832;">, </span>nextProps)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>isCustomComponentTag = <span style="color:#ffc66d;">isCustomComponent</span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_tag</span><span style="color:#cc7832;">, </span>nextProps)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#808080;">//根据新旧props的差异更新对应dom元素上的属性<br/></span><span style="color:#808080;">  </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_updateDOMProperties</span>(lastProps<span style="color:#cc7832;">, </span>nextProps<span style="color:#cc7832;">, </span>transaction<span style="color:#cc7832;">, </span>isCustomComponentTag)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#808080;">//更新子节点内容，diff算法（diff算法下文将详细介绍）<br/></span><span style="color:#808080;">  </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_updateDOMChildren</span>(<br/>    lastProps<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>nextProps<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>context<br/>  )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#808080;">//更新节点后根据新的props中的值设置dom属性比如value、checked等<br/></span><span style="color:#808080;">  </span><span style="color:#cc7832;font-weight:bold;">switch </span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_tag</span>) {<br/>    <span style="color:#cc7832;font-weight:bold;">case </span><span style="color:#6a8759;">'input'</span>:<br/>      <span style="color:#808080;">// Update the wrapper around inputs *after* updating props. This has to<br/></span><span style="color:#808080;">      // happen after `_updateDOMProperties`. Otherwise HTML5 input validations<br/></span><span style="color:#808080;">      // raise warnings and prevent the new value from being assigned.<br/></span><span style="color:#808080;">      </span>ReactDOMInput.<span style="color:#ffc66d;">updateWrapper</span>(<span style="color:#cc7832;font-weight:bold;">this</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">      </span><span style="color:#cc7832;font-weight:bold;">break</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    <b>//略去其他……</b></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span>}<br/>}<span style="color:#cc7832;">,</span>
</pre><br/></div><div>3）unmountComponent 去掉React Component实例上的事件监听器，循环调用子组件的unmountComponent方法，不直接删除dom节点，由父节点统一清除。</div><div><br/></div><div>1.3）<font style="font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; background-color: rgb(248, 248, 248); color: rgb(78, 89, 128);">ReactCompositeComponent</font></div><div><br/></div><div> 1）mountComponent</div><div style="text-align: center; "><img src="/images/2017-01-20/%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%9B%BE%20(2).png" height="548" width="213"/><br/></div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><br/><span style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Initializes the component, renders markup, and registers event listeners.<br/></span><span style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactReconcileTransaction|ReactServerRenderingTransaction} transaction<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{?object} hostParent<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{?object} hostContainerInfo<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{?object} context<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@return </span><span style="color:#629755;font-style:italic;">{?string} Rendered markup to be inserted into the DOM.<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@final<br/></span><span style="color:#629755;font-weight:bold;font-style:italic;" /><span style="color:#629755;font-style:italic;">* </span><span style="color:#629755;font-weight:bold;font-style:italic;">@internal<br/></span><span style="color:#629755;font-weight:bold;font-style:italic;" /><span style="color:#629755;font-style:italic;">*/<br/></span>mountComponent: <span style="color:#cc7832;font-weight:bold;">function</span>(<br/>    transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>hostParent<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>hostContainerInfo<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>context<br/>) {<br/>    <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_context </span>= context<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_mountOrder </span>= nextMountID++<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_hostParent </span>= hostParent<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_hostContainerInfo </span>= hostContainerInfo<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>publicProps = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_currentElement</span>.<span style="color:#9876aa;">props</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>publicContext = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_processContext</span>(context)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>Component = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_currentElement</span>.<span style="color:#9876aa;">type</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>updateQueue = transaction.<span style="color:#ffc66d;">getUpdateQueue</span>()<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;">// Initialize the public class<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>doConstruct = <span style="color:#ffc66d;">shouldConstruct</span>(Component)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>inst = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_constructComponent</span>(<br/>        doConstruct<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>publicProps<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>publicContext<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>updateQueue<br/>    )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>renderedElement<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;">// Support functional components<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(!doConstruct &amp;&amp; (inst == <span style="color:#cc7832;font-weight:bold;">null </span>|| inst.<span style="color:#ffc66d;">render </span>== <span style="color:#cc7832;font-weight:bold;">null</span>)) {<br/>        renderedElement = inst<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>inst = <span style="color:#cc7832;font-weight:bold;">new </span><span style="color:#ffc66d;">StatelessComponent</span>(Component)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_compositeType </span>= ReactCompositeComponentTypes.<span style="color:#9876aa;">StatelessFunctional</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>} <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>        <span style="color:#cc7832;font-weight:bold;">if </span>(<span style="color:#ffc66d;">isPureComponent</span>(Component)) {<br/>            <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_compositeType </span>= ReactCompositeComponentTypes.<span style="color:#9876aa;">PureClass</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>} <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>            <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_compositeType </span>= ReactCompositeComponentTypes.<span style="color:#9876aa;">ImpureClass</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>}<br/>    }<br/><br/>    <span style="color:#808080;">// These should be set up in the constructor, but as a convenience for<br/></span><span style="color:#808080;">    // simpler class abstractions, we set them up after the fact.<br/></span><span style="color:#808080;">    </span>inst.<span style="color:#9876aa;">props </span>= publicProps<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>inst.<span style="color:#9876aa;">context </span>= publicContext<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>inst.<span style="color:#9876aa;">refs </span>= emptyObject<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>inst.<span style="color:#9876aa;">updater </span>= updateQueue<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_instance </span>= inst<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;">// Store a reference from the instance back to the internal representation<br/></span><span style="color:#808080;">    </span>ReactInstanceMap.<span style="color:#ffc66d;">set</span>(inst<span style="color:#cc7832;">, </span><span style="color:#cc7832;font-weight:bold;">this</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>initialState = inst.<span style="color:#9876aa;">state</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(initialState === <span style="color:#9876aa;">undefined</span>) {<br/>        inst.<span style="color:#9876aa;">state </span>= initialState = <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/><br/>    <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_pendingStateQueue </span>= <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_pendingReplaceState </span>= <span style="color:#cc7832;font-weight:bold;">false</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_pendingForceUpdate </span>= <span style="color:#cc7832;font-weight:bold;">false</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;">//调用生命周期函数<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(inst.<span style="color:#9876aa;">componentWillMount</span>) {<br/>        inst.<span style="color:#9876aa;">componentWillMount</span>()<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#808080;">// When mounting, calls to `setState` by `componentWillMount` will set<br/></span><span style="color:#808080;">        // `this._pendingStateQueue` without triggering a re-render.注意这里新的state是在</span><span style="color: rgb(152, 118, 170); font-size: 9pt;">componentWillMount执行完后更新的，因此在<font style="font-family: Menlo; font-size: 12px; background-color: rgb(43, 43, 43); color: rgb(152, 118, 170);">componentWillMount</font>里的this.state不是最新的</span><span style="color:#808080;"><br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">if </span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_pendingStateQueue</span>) {<br/>            inst.<span style="color:#9876aa;">state </span>= <span style="color:#cc7832;font-weight:bold;">this</span>._processPendingState(inst.<span style="color:#9876aa;">props</span><span style="color:#cc7832;">, </span>inst.<span style="color:#9876aa;">context</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>}<br/>    }<br/><br/>    <span style="color:#cc7832;font-weight:bold;">var </span>markup<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;">//带错误监听，内部调用performInitialMount，render函数返回的内容用来初始化一个ReactComponent实例，然后调用ReactReconciler.mountComponent获得dom树<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(inst.<span style="color:#ffc66d;">unstable_handleError</span>) {<br/>        markup = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">performInitialMountWithErrorHandling</span>(<br/>            renderedElement<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>hostParent<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>hostContainerInfo<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>context<br/>        )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>} <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>        markup = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">performInitialMount</span>(<br/>            renderedElement<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>hostParent<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>hostContainerInfo<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>context<br/>        )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/>    <span style="color:#808080;">//<font style="font-family: Menlo; font-size: 12px; background-color: rgb(43, 43, 43); color: rgb(255, 198, 109);">componentDidMount执行</font><br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(inst.<span style="color:#ffc66d;">componentDidMount</span>) {<br/>        transaction.<span style="color:#ffc66d;">getReactMountReady</span>().<span style="color:#ffc66d;">enqueue</span>(inst.<span style="color:#ffc66d;">componentDidMount</span><span style="color:#cc7832;">, </span>inst)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/><br/>    <span style="color:#808080;">// setState callbacks during willMount should end up here<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">const </span>callbacks = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_pendingCallbacks</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(callbacks) {<br/>        <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_pendingCallbacks </span>= <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">for </span>(let i = <span style="color:#6897bb;">0</span><span style="color:#cc7832;">; </span>i &lt; callbacks.<span style="color:#9876aa;">length</span><span style="color:#cc7832;">; </span>i++) {<br/>            transaction.<span style="color:#ffc66d;">getReactMountReady</span>().<span style="color:#ffc66d;">enqueue</span>(<br/>                callbacks[i]<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">                </span>inst<br/>            )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>}<br/>    }<br/><br/>    <span style="color:#cc7832;font-weight:bold;">return </span>markup<span style="color:#cc7832;">;<br/></span>}<span style="color:#cc7832;">,</span>
</pre><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#cc7832;"><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#ffc66d;">performInitialMount</span>: <span style="color:#cc7832;font-weight:bold;">function</span>(<br/>  renderedElement<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>hostParent<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>hostContainerInfo<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>context<br/>) {<br/>  <span style="color:#808080;">// If not a stateless component, we now render<br/></span><span style="color:#808080;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(renderedElement === <span style="color:#9876aa;">undefined</span>) {<br/>    renderedElement = <span style="color:#cc7832;font-weight:bold;">this</span>._renderValidatedComponent()<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/><br/>  <span style="color:#cc7832;font-weight:bold;">var </span>nodeType = ReactNodeTypes.<span style="color:#ffc66d;">getType</span>(renderedElement)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_renderedNodeType </span>= nodeType<span style="color:#cc7832;">;</span></pre><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#cc7832;">  //得到当前ReactElement对应的ReactComponent实例<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>child = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_instantiateReactComponent</span>(<br/>    renderedElement<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>nodeType !== ReactNodeTypes.<span style="color:#9876aa;">EMPTY </span><span style="color:#808080;">/* shouldHaveDebugID */<br/></span><span style="color:#808080;">  </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_renderedComponent </span>= child<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>debugID = <span style="color:#6897bb;">0</span><span style="color:#cc7832;">;</span><br/>  //递归生成子节点dom树<br/>  <span style="color:#cc7832;font-weight:bold;">var </span>markup = ReactReconciler.<span style="color:#ffc66d;">mountComponent</span>(<br/>    child<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>hostParent<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>hostContainerInfo<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_processChildContext</span>(context)<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>debugID<br/>  )<span style="color:#cc7832;">;</span><br/><br/>  <span style="color:#cc7832;font-weight:bold;">return </span>markup<span style="color:#cc7832;">;<br/></span>}<span style="color:#cc7832;">,<br/></span>
</pre><br/></span></pre>2）receiveComponent </div><div>这里负责生命周期的componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate。注意在前三个生命周期函数中调用this.state无法获取更新后的this.state因为为实例更新state的inst.state=nextState在componentWillUpdate之后调用，即render和componentDidUpdate中可以，禁止在shouldComponentUpdate和componentWillUpdate中调用setState，会造成循环调用（原因参见src/renderers/shared/stack/reconciler/ReactCompositeComponent.js的performUpdateIfNecessary方法）</div><div style="text-align: center; "><img src="/images/2017-01-20/%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%9B%BE%20(3).png" height="685" width="564"/><br/></div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><br/><span style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Perform an update to a mounted component. The componentWillReceiveProps and<br/></span><span style="color:#629755;font-style:italic;"> * shouldComponentUpdate methods are called, then (assuming the update isn't<br/></span><span style="color:#629755;font-style:italic;"> * skipped) the remaining update lifecycle methods are called and the DOM<br/></span><span style="color:#629755;font-style:italic;"> * representation is updated.<br/></span><span style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * By default, this implements React's rendering and reconciliation algorithm.<br/></span><span style="color:#629755;font-style:italic;"> * Sophisticated clients may wish to override this.<br/></span><span style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactReconcileTransaction} transaction<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactElement} prevParentElement<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactElement} nextParentElement<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@internal<br/></span><span style="color:#629755;font-weight:bold;font-style:italic;" /><span style="color:#629755;font-style:italic;">* </span><span style="color:#629755;font-weight:bold;font-style:italic;">@overridable<br/></span><span style="color:#629755;font-weight:bold;font-style:italic;" /><span style="color:#629755;font-style:italic;">*/<br/></span>updateComponent: <span style="color:#cc7832;font-weight:bold;">function</span>(<br/>    transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>prevParentElement<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>nextParentElement<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>prevUnmaskedContext<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>nextUnmaskedContext<br/>) {<br/>    <span style="color:#cc7832;font-weight:bold;">var </span>inst = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_instance</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>willReceive = <span style="color:#cc7832;font-weight:bold;">false</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>nextContext<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;">// Determine if the context has changed or not<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_context </span>=== nextUnmaskedContext) {<br/>        nextContext = inst.<span style="color:#9876aa;">context</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>} <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>        nextContext = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">_processContext</span>(nextUnmaskedContext)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>willReceive = <span style="color:#cc7832;font-weight:bold;">true</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/><br/>    <span style="color:#cc7832;font-weight:bold;">var </span>prevProps = prevParentElement.<span style="color:#9876aa;">props</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>nextProps = nextParentElement.<span style="color:#9876aa;">props</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#808080;">// Not a simple state update but a props update<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(prevParentElement !== nextParentElement) {<br/>        willReceive = <span style="color:#cc7832;font-weight:bold;">true</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/><br/>    <span style="color:#808080;">// An update here will schedule an update but immediately set<br/></span><span style="color:#808080;">    // _pendingStateQueue which will ensure that any state updates gets<br/></span><span style="color:#808080;">    // immediately reconciled instead of waiting for the next batch.<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(willReceive &amp;&amp; inst.<span style="color:#ffc66d;">componentWillReceiveProps</span>) {<br/>        inst.<span style="color:#ffc66d;">componentWillReceiveProps</span>(nextProps<span style="color:#cc7832;">, </span>nextContext)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/><br/>    <span style="color:#808080;">// If updating happens to enqueue any new updates, we shouldn't execute new<br/></span><span style="color:#808080;">    // callbacks until the next render happens, so stash the callbacks first.<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>callbacks = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_pendingCallbacks</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_pendingCallbacks </span>= <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>nextState = <span style="color:#cc7832;font-weight:bold;">this</span>._processPendingState(nextProps<span style="color:#cc7832;">, </span>nextContext)<span style="color:#cc7832;">; </span><span style="color:#808080;">//获得nextState<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>shouldUpdate = <span style="color:#cc7832;font-weight:bold;">true</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(!<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_pendingForceUpdate</span>) { <span style="color:#808080;">//没设置forseupdate<br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">var </span>prevState = inst.<span style="color:#9876aa;">state</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>shouldUpdate = willReceive || nextState !== prevState<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#808080;">//如果提供shouldComponentUpdate，调用函数，否则新旧state和props浅比较确定是否更新<br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">if </span>(inst.<span style="color:#ffc66d;">shouldComponentUpdate</span>) {<br/>            shouldUpdate = inst.<span style="color:#ffc66d;">shouldComponentUpdate</span>(nextProps<span style="color:#cc7832;">, </span>nextState<span style="color:#cc7832;">, </span>nextContext)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>} <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>            <span style="color:#cc7832;font-weight:bold;">if </span>(<span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_compositeType </span>=== ReactCompositeComponentTypes.<span style="color:#9876aa;">PureClass</span>) {<br/>                shouldUpdate =<br/>                    !shallowEqual(prevProps<span style="color:#cc7832;">, </span>nextProps) ||<br/>                    !shallowEqual(inst.<span style="color:#9876aa;">state</span><span style="color:#cc7832;">, </span>nextState)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">            </span>}<br/>        }<br/>    }<br/><br/>    <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_updateBatchNumber </span>= <span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(shouldUpdate) {<br/>        <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_pendingForceUpdate </span>= <span style="color:#cc7832;font-weight:bold;">false</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#808080;">// Will set `this.props`, `this.state` and `this.context`.<br/></span><span style="color:#808080;">        //设置新props、state，调用生命周期函数（如果提供），更新dom<br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">this</span>._performComponentUpdate(<br/>            nextParentElement<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>nextProps<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>nextState<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>nextContext<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">            </span>nextUnmaskedContext<br/>        )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>} <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>        <span style="color:#808080;">// If it's determined that a component should not update, we still want<br/></span><span style="color:#808080;">        // to set props and state but we shortcut the rest of the update.<br/></span><span style="color:#808080;">        </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_currentElement </span>= nextParentElement<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_context </span>= nextUnmaskedContext<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>inst.<span style="color:#9876aa;">props </span>= nextProps<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>inst.<span style="color:#9876aa;">state </span>= nextState<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>inst.<span style="color:#9876aa;">context </span>= nextContext<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>}<br/>    <span style="color:#808080;">//render之后调用的事件队列<br/></span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">if </span>(callbacks) {<br/>        <span style="color:#cc7832;font-weight:bold;">for </span>(<span style="color:#cc7832;font-weight:bold;">var </span>j = <span style="color:#6897bb;">0</span><span style="color:#cc7832;">; </span>j &lt; callbacks.<span style="color:#9876aa;">length</span><span style="color:#cc7832;">; </span>j++) {<br/>            transaction.<span style="color:#ffc66d;">getReactMountReady</span>().<span style="color:#ffc66d;">enqueue</span>(<br/>                callbacks[j]<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">                </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#ffc66d;">getPublicInstance</span>()<br/>            )<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">        </span>}<br/>    }<br/>}<span style="color:#cc7832;">,</span>
</pre><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Merges new props and state, notifies delegate methods of update and<br/></span><span style="color:#629755;font-style:italic;"> * performs update.<br/></span><span style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactElement} nextElement Next element<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{object} nextProps Next public object to set as properties.<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{?object} nextState Next object to set as state.<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{?object} nextContext Next public object to set as context.<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactReconcileTransaction} transaction<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{?object} unmaskedContext<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@private<br/></span><span style="color:#629755;font-weight:bold;font-style:italic;" /><span style="color:#629755;font-style:italic;">*/<br/></span>_performComponentUpdate: <span style="color:#cc7832;font-weight:bold;">function</span>(<br/>  nextElement<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>nextProps<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>nextState<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>nextContext<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>unmaskedContext<br/>) {<br/>  <span style="color:#cc7832;font-weight:bold;">var </span>inst = <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_instance</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>hasComponentDidUpdate = Boolean(inst.<span style="color:#ffc66d;">componentDidUpdate</span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>prevProps<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>prevState<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">var </span>prevContext<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(hasComponentDidUpdate) {<br/>    prevProps = inst.<span style="color:#9876aa;">props</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>prevState = inst.<span style="color:#9876aa;">state</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>prevContext = inst.<span style="color:#9876aa;">context</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/><br/>  <span style="color:#cc7832;font-weight:bold;">if </span>(inst.<span style="color:#ffc66d;">componentWillUpdate</span>) {<br/>     inst.<span style="color:#ffc66d;">componentWillUpdate</span>(nextProps<span style="color:#cc7832;">, </span>nextState<span style="color:#cc7832;">, </span>nextContext)<span style="color:#cc7832;">;</span><br/>  }<br/><br/>  <span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_currentElement </span>= nextElement<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">this</span>.<span style="color:#9876aa;">_context </span>= unmaskedContext<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>inst.<span style="color:#9876aa;">props </span>= nextProps<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>inst.<span style="color:#9876aa;">state </span>= nextState<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>inst.<span style="color:#9876aa;">context </span>= nextContext<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(inst.<span style="color:#ffc66d;">unstable_handleError</span>) {<br/>    <span style="color:#cc7832;font-weight:bold;">this</span>._updateRenderedComponentWithErrorHandling(transaction<span style="color:#cc7832;">, </span>unmaskedContext)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>} <span style="color:#cc7832;font-weight:bold;">else </span>{<br/>    <span style="color:#cc7832;font-weight:bold;">this</span>._updateRenderedComponent(transaction<span style="color:#cc7832;">, </span>unmaskedContext)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/><br/>  <span style="color:#cc7832;font-weight:bold;">if </span>(hasComponentDidUpdate) {<br/>      transaction.<span style="color:#ffc66d;">getReactMountReady</span>().<span style="color:#ffc66d;">enqueue</span>(<br/>        inst.<span style="color:#ffc66d;">componentDidUpdate</span>.<span style="color:#ffc66d;">bind</span>(inst<span style="color:#cc7832;">, </span>prevProps<span style="color:#cc7832;">, </span>prevState<span style="color:#cc7832;">, </span>prevContext)<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">        </span>inst<br/>      )<span style="color:#cc7832;">;</span><br/>  }<br/>}<span style="color:#cc7832;">,</span>
</pre><br/></div><div>3）unmountComponent 调用生命周期函数componentWillUnmount（如果提供），调用当前组件对应的React Component实例对应的unmountComponent函数，重置一堆变量。</div><div><br/></div><div><br/></div><div/><ol start="2"><li>渲染组件的工作主要在这个函数，通过<font style="font-family: Helvetica; color: rgb(69, 69, 69);">instantiateReactComponent</font>得到了各种类型组件对应的ReactComponent实例（可以理解为一个ReactComponent实例的树，包含所有子节点的ReactComponent实例），然后调用实例的mountComponent方法（上面讲解过）得到要渲染的‘markup’可能是一个dom树，或一个DOMLazyTree结构保存将子节点的dom结构树保存到数组里，最后插入到container中。</li></ol></div><div><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;"><span style="color:#629755;font-style:italic;">/**<br/></span><span style="color:#629755;font-style:italic;"> * Mounts this component and inserts it into the DOM.<br/></span><span style="color:#629755;font-style:italic;"> *<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactComponent} componentInstance The instance to mount.<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{DOMElement} container DOM element to mount into.<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{ReactReconcileTransaction} transaction<br/></span><span style="color:#629755;font-style:italic;"> * </span><span style="color:#629755;font-weight:bold;font-style:italic;">@param </span><span style="color:#629755;font-style:italic;">{boolean} shouldReuseMarkup If true, do not insert markup<br/></span><span style="color:#629755;font-style:italic;"> */<br/></span><span style="color:#cc7832;font-weight:bold;">function </span><span style="color:#ffc66d;">mountComponentIntoNode</span>(<br/>  wrapperInstance<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>container<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>shouldReuseMarkup<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">  </span>context<br/>) {<br/>  <span style="color:#cc7832;font-weight:bold;">var </span>markerName<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(ReactFeatureFlags.<span style="color:#9876aa;">logTopLevelRenders</span>) { //记录拼接组件对应的dom模板所用的时长<br/>    <span style="color:#cc7832;font-weight:bold;">var </span>wrappedElement = wrapperInstance.<span style="color:#9876aa;">_currentElement</span>.<span style="color:#9876aa;">props</span>.child<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">var </span>type = wrappedElement.<span style="color:#9876aa;">type</span><span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span>markerName = <span style="color:#6a8759;">'React mount: ' </span>+ (<br/>      <span style="color:#cc7832;font-weight:bold;">typeof </span>type === <span style="color:#6a8759;">'string' </span>? type :<br/>      type.<span style="color:#9876aa;">displayName </span>|| type.<span style="color:#9876aa;">name<br/></span><span style="color:#9876aa;">    </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">    </span><span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">time</span>(markerName)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/><br/>  <span style="color:#cc7832;font-weight:bold;">var </span>markup = ReactReconciler.<span style="color:#ffc66d;">mountComponent</span>( //调用组件实例的mountComponent方法获得要渲染的结构（可能是一个html片段或一个src/<font style="font-size: 12px; color: rgb(169, 183, 198); font-family: Menlo;">renderers/dom/stack/client/DOMLazyTree.js结构）</font>，添加事件以及ref属性<br/>    wrapperInstance<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>transaction<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">null</span><span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>ReactDOMContainerInfo(wrapperInstance<span style="color:#cc7832;">, </span>container)<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>context<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span><span style="color:#6897bb;">0 </span><span style="color:#808080;">/* parentDebugID */<br/></span><span style="color:#808080;">  </span>)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;"><br/></span><span style="color:#cc7832;">  </span><span style="color:#cc7832;font-weight:bold;">if </span>(markerName) {<br/>    <span style="color:#9876aa;">console</span>.<span style="color:#ffc66d;">timeEnd</span>(markerName)<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>}<br/><br/>  wrapperInstance.<span style="color:#9876aa;">_renderedComponent</span>.<span style="color:#9876aa;">_topLevelWrapper </span>= wrapperInstance<span style="color:#cc7832;">;<br/></span><span style="color:#cc7832;">  </span>ReactMount.<span style="color:#ffc66d;">_mountImageIntoNode</span>( //将上面得到的结构（递归）渲染到container dom节点中，显示在页面上<br/>    markup<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>container<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>wrapperInstance<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>shouldReuseMarkup<span style="color:#cc7832;">,<br/></span><span style="color:#cc7832;">    </span>transaction<br/>  )<span style="color:#cc7832;">;<br/></span>}
</pre><br/></div><div>以上是对虚拟dom和渲染策略的讲解。</div><div><br/></div><div>推荐阅读：</div><div><span style="font: 12.0px Helvetica; color: #e4af09"><a href="https://zhuanlan.zhihu.com/purerender">https://zhuanlan.zhihu.com/purerender</a></span><span style="font: 12.0px Helvetica; color: #454545" /><span style="font: 12.0px 'PingFang SC'; color: #454545">关于</span><span style="font: 12.0px Helvetica; color: #454545">react</span><span style="font: 12.0px 'PingFang SC'; color: #454545">源码解析系列文章</span><span style="font: 12.0px Helvetica; color: #454545"><br/>
<span style="color: #e4af09"><a href="http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one/">http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one/</a></span></span></div><div><span style="font-style: normal; font-variant-caps: normal; font-weight: normal; font-size: 12px; font-family: Helvetica;"><font color="#e4af09">《深入React技术栈》这本书的第三章（有需要可以找我借）<br/></font>
</span><br/></div><div><br/></div><div><br/></div>